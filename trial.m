function [RT, ER, RDir, score, premie_t,premie_d,timeS] = ...    trial (dotsIdx, targetIdx, blackTargetIdx, textIdx, ppd_, direc, corcode, D, shape, scorein, ntrial, ...	money, salary, ...    pahandle_correct, pahandle_antic, daq )% function [RT, ER, score] = trial (windowptr, direc, corkey, D ,Dpen, scorein)% % One experimental trial% Inputs:%  windowptr - pointer to the screen window%  direc - direction of dots%  corkey - correct key for this trial as number by crazy Mac%  D - Response-Stimulus Interval%  Dpen - Additional Delay after making an error%  scorein - starting score of the subject% Outputs:%  RT - reaction time [in seconds]%  ER - error = 1, correct = 0%  score - score after the trial% % 'feedback' -- flag indicating whether feedback should be presentedrSet('dXdots',dotsIdx,'direction',direc,'visible',true);rSet('dXtarget',targetIdx,'visible',true);rSet('dXtarget',blackTargetIdx,'visible',true);if daq ~= -1    if direc == 0        DaqDOut(daq, 0, 10);   % 1 volt is for Rightward motion    else        DaqDOut(daq, 0, 5); % 0.5 volts is for Leftward motion    endendtimeS = GetSecs;[ mySecs, myKeyCode ] = rGraphicsDrawSelectiveBreak(inf,[],[29 16]);if daq ~= -1    DaqDOut(daq, 0, 0);endtimeR = mySecs;rSet('dXdots',dotsIdx,'visible',false);rGraphicsDraw;% Throwing in a check here to make sure that timeR is not less than % 100 msec. If so, incur a penalty and move to penalizing delay period, % returning the normal statistics that would've been returned (thus % the code that analyzes statistics should take care of RTs of < 100 % msec, by throwing those trials out). Currently this version of the % code does not return the number of premature presses.RT = timeR - timeS;keynum = find(myKeyCode);if isempty (keynum)	keynum = 0;endER = (keynum(1) ~= corcode);% Here's the 100 msec check:if RT > 0.1	score = scorein + ~ER;else	score = scorein;end% Get the particular direction of this trial:if keynum == 29	RDir = 'L';elseif keynum == 16	RDir = 'R';else	RDir = '-';endfeedback = 1;% 10/27/08: Now making a gamma-distributed RSI, with shape and mean% parameters sent by the calling function: scale = D/shape;RSI = gamrnd(shape,scale);% if response wasn't too early...if RT > 0.1    % if error, 	if ER		delay = RSI;            % if OK,	elseif feedback		dur = makesound2(pahandle_correct);		delay = RSI - dur;    else		delay = RSI;	end	% Every 10 trials, display feedback for 0.5 seconds:    if (mod( ntrial, 5 ) == 1) && feedback        rGraphicsBlank;        fontsize = 20;        str = sprintf ('Score: %d', score);        textwidth = fontsize*length(str)/ppd_;        x_pos = -0.3*textwidth;        rSet( ...            'dXtext', textIdx, ...            'string', str, ...            'visible',true, ...            'x', x_pos, 'y', 0, ...            'size', fontsize);        rGraphicsDraw(delay);    end    % if response was too early...    else	% This is a penalty delay, so might as well make it big:	dur = makesound2(pahandle_antic);	delay = 4 - dur;endpremie_t = []; premie_d = [];% 5/3/06: Soak up any continuous button pressing and don't do anything during such a time:while KbCheckMulti    WaitSecs(0.001);end% Get a current time for the offset of the subject's keypress:start = GetSecs;% Wait for the RSI to expire. If it does, return. If it doesn't, go to the premie keypress % code below:while ~KbCheckMulti	s = GetSecs - start;    WaitSecs(0.001);	if s >= delay%         rDone;            rGraphicsBlank;		return	endend% If the function gets to here, then they made a premature keypress, % so penalize them:% dur = makesound;% 	start = GetSecs;% 9/14/05: Could determine inter-premature-press interval here:% premie_t = []; premie_d = [];% 5/3/06: make delay 4 seconds:s = GetSecs;% This is a penalty delay, so might as well make it big:% dur = makesound('errorsound');dur = makesound2(pahandle_antic);delay = 4 - dur;premie_t = [premie_t, s - start];start = s;keynum = find(myKeyCode);if isempty (keynum)	keynum = 0;end% if keynum == 7if keynum == 29	premie_d = [premie_d,'L'];% elseif keynum == 47elseif keynum == 16	premie_d = [premie_d,'R'];else	premie_d = [premie_d,'-'];endwhile 1% 	n = 0.1 * randn( 1 );% 	if n < -D% 		n = -D + 0.01;% 	end	% Empty loop to absorb continuous pressing:	while KbCheckMulti		WaitSecs(0.001);	end	while ~KbCheckMulti		s = GetSecs - start;        WaitSecs(0.001);		if s >= delay            %             rDone;            rGraphicsBlank;            			return		end	end	% 	dur = makesound;		% 	start = GetSecs;	% 9/14/05: Could determine inter-premature-press interval here:	s = GetSecs;	% This is a penalty delay, so might as well make it big:% 	dur = makesound('errorsound');    dur = makesound2(pahandle_antic);	delay = 4 - dur;% 	premie = s - start;	premie_t = [premie_t, s - start];	start = s;	keynum = find(myKeyCode);	if isempty (keynum)		keynum = 0;	end% 	if keynum == 7	if keynum == 29		premie_d = [premie_d,'L'];% 	elseif keynum == 47	    elseif keynum == 16		premie_d = [premie_d,'R'];	else		premie_d = [premie_d,'-'];	endend