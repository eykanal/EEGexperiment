function [RT, ER, RDir, score] = sig_det_trial (windowptr, direc, corkey, D, scorein, respdir)% function [RT,ER,score] = sig_det_trial(windowptr,direc,corkey,D,scorein)%% This version of trial.m records legal RTs for any stimulus as correct, in % order to determine the speed of signal detection in a subject.% respdir is a string specifying left or right responses.% function [RT, ER, score] = trial (windowptr, direc, corkey, D ,Dpen, scorein)% % One experimental trial% Inputs:%  windowptr - pointer to the screen window%  direc - direction of dots%  corkey - correct key for this trial as number by crazy Mac%  D - Response-Stimulus Interval%  Dpen - Additional Delay after making an error%  scorein - starting score of the subject% Outputs:%  RT - reaction time [in seconds]%  ER - error = 1, correct = 0%  score - score after the trial% if corkey == 'Z'	%Mac has strange representation of keys: z=7, m=47% 	corcode = 7;% else% 	corcode = 47;% end% Change to accepting only responses in respdir direction:if strcmp( 'Left', respdir) == 1	corcode = 7;else	corcode = 47;endrSet ('dots', [1], 'direction', direc);% Set direction of dots movementrRecurStart ('dots', [1], [1]);% Puts dots on the list of objects to be displayed recursivellytimeS = GetSecs;while KbCheck   %empty loop to avoid pressing the button continuouslyendwhile ~KbCheck	rWaitVBL;	% Waits to the refresh of the monitor	rRecur;		% Plots all the objects on the list of recursive objectsendtimeR = GetSecs;% Throwing in a check here to make sure that timeR is not less than % 100 msec. If so, incur a penalty and move to penalizing delay period, % returning the normal statistics that would've been returned (thus % the code that analyzes statistics should take care of RTs of < 100 % msec, by throwing those trials out). Currently this version of the % code does not return the number of premature presses.RT = timeR - timeS;[keydown, secs, keycode] = KbCheck;keynum = find(keycode);if isempty (keynum)	keynum = 0;endER = (keynum(1) ~= corcode);% Here's the 100 msec check:if RT > 0.1	score = scorein + ~ER;else	score = scorein;end% Get the particular direction of this trial:if keynum == 7	RDir = 'L';elseif keynum == 47	RDir = 'R';else	RDir = '-';endrRecurStop ('dots', [1]);% Stops movement of dots% Get a normally distributed random increment to add on to D % in order to vary the stimulus onset for this trial (make sure % that D + increment is not less than 0):% n = 0.1 * randn( 1 );% Increasing variability to get better signal detection times (I % was able to anticipate for n = 0.1*randn(1);n = 0.5 * randn(1);if n < -D	n = -D + 0.01;endif RT > 0.1	TextCenter (windowptr, sprintf ('Score: %d', score), 0, 12);	if ER		% 	WaitSecs (D);		% 	WaitSecs (D-n);		delay = D + n;	else		dur = makesound;		%    WaitSecs (D - dur);		%    WaitSecs (D-n - dur);		delay = D + n - dur;	endelse	delay = D + n;end% Get a current time:start = GetSecs;while KbCheckendwhile ~KbCheck	s = GetSecs - start;	if s >= delay		return	endend% If the function gets to here, then they made a premature keypress, % so penalize them:% dur = makesound;start = GetSecs;while 1	n = 0.1 * randn( 1 );	if n < -D		n = -D + 0.01;	end	while KbCheck		;	end	while ~KbCheck		s = GetSecs - start;		if s >= delay			return		end	end	% 	dur = makesound;	start = GetSecs;end