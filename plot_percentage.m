function plot_percentage( subject );% This function plots the percentage of bias-congruent responses % as a function of delay.load(subject);  % Get some data% Data for each trial is recorded separately, and the variable % blocknum identifies the block that each one is in.% For each delay condition, get percentage of responses congruent% with the current bias.% Each delay condition will be randomly scattered throughout the % data, so scan forward from the beginning, noting the blocknum % value. Assuming the number of delay conditions is 3 and biases % is 4.Delay = [ 0.25 1 2 ];Bias = [ 0.6 0.75 0.9 ];% Here's a data structure with one column of each congruent percentage % for each row of delays.Congruent_stats = zeros( length(Delay), length(Bias) );% Also plotting RT and ER for the different blocks:RT_stats = zeros( length(Delay), length(Bias) );ER_stats = zeros( length(Delay), length(Bias) );% Now scan through the data one time, computing and assigning % values for the above data structures:tmpblocknum = 1;congruent_total = 0;congruent_percent = 0;% New stats in addition to congruence percentage:mean_rt = 0;mean_er = 0;rt_total = 0;er_total = 0;trial_total = 0;current_bias = PI(1);current_delay = D(1);for i = 1:length(trialnum)		if tmpblocknum ~= blocknum(i)		% New block:		% First, store current data in appropriate structure:		congruent_percent = congruent_total / trial_total;				mean_rt = rt_total / trial_total;		mean_er = er_total / trial_total;				for j = 1:length(Delay)			if Delay(j) == current_delay				delay_idx = j;				break			end		end			for k = 1:length(Bias)			if Bias(k) == current_bias				bias_idx = k;				break			end		end			Congruent_stats(j,k) = congruent_percent;				% New stats:		RT_stats(j,k) = mean_rt;		ER_stats(j,k) = mean_er;						% Now get ready for new data:		tmpblocknum = blocknum(i);		congruent_total = 0;		congruent_percent = 0;				% New stats in addition to congruence percentage:		mean_rt = 0;		mean_er = 0;		rt_total = 0;		er_total = 0;				trial_total = 0;		current_bias = PI(i);		current_delay = D(i);	end	trial_total = trial_total + 1;		% Unfortunately, didn't record RDir in the newest tapping software.	% So can compare ST and ER to see if the response was in the 	% direction of the provided stimulus, and then see if the stimulus	% was in the bias direction.	% 	if strcmp( PiDir(i), RDir(i) )	% 		congruent_total = congruent_total + 1;	% 	end	if strcmp( ST(i), 'L' )		if ER(i) == 1			RDir = 'R';		else			RDir = 'L';		end	else		if ER(i) == 1;			RDir = 'L';		else			RDir = 'R';		end	end	if strcmp( PiDir(i), RDir )		congruent_total = congruent_total + 1;	end	% New error rate and reaction time stats:	if ER(i) == 1		er_total = er_total + 1;	end	rt_total = rt_total + RT(i);		end% Don't forget the very last condition which gets missed in the % above loop:% First, store current data in appropriate structure:congruent_percent = congruent_total / trial_total;mean_rt = rt_total / trial_total;mean_er = er_total / trial_total;for j = 1:length(Delay)	if Delay(j) == current_delay		delay_idx = j;		break	endendfor k = 1:length(Bias)	if Bias(k) == current_bias		bias_idx = k;		break	endendCongruent_stats(j,k) = congruent_percent;% New stats:RT_stats(j,k) = mean_rt;ER_stats(j,k) = mean_er;% Now plot the congruence data, one plot per delay condition:for i = 1:length(Delay)	figure;	plot( Bias, Congruent_stats(i,:) );	title( sprintf( 'CongruencePlot: Delay = %f', Delay(i) ) );end% Now plot the RT data, one plot per delay condition:for i = 1:length(Delay)	figure;	plot( Bias, RT_stats(i,:), 'r' );	title( sprintf( 'RT Plot: Delay = %f', Delay(i) ) );end% Now plot the ER data, one plot per delay condition:for i = 1:length(Delay)	figure;	plot( Bias, ER_stats(i,:), 'g' );	title( sprintf( 'ER Plot: Delay = %f', Delay(i) ) );endkeyboard