function [RT, ER, RDir, score, premie_t, premie_d, timeS, ...    dot_onset_time, dot_duration, dot_offset_time,irrelevantMotionDir] =...trial_arrow (dotsIdx, targetIdx, triangleIdx, blackTargetIdx, textIdx, ...    ppd_, direc, corcode, lkey, rkey, D, shape, scorein, ntrial, money, ...    salary, wdwPtr, cue_type, pahandle_correct, pahandle_antic, daq, ...    contrast_factor, Behavioral, dot_duration, coher_bit )% One experimental trial% Inputs:%  windowptr - pointer to the screen window%  direc - direction of dots%  corkey - correct key for this trial as number by crazy Mac%  D - Response-Stimulus Interval%  Dpen - Additional Delay after making an error%  scorein - starting score of the subject% Outputs:%  RT - reaction time [in seconds]%  ER - error = 1, correct = 0%  score - score after the trial% % 'feedback' -- flag indicating whether feedback should be presentedpremature_arrow = 0;% Get window dimensions to allow a big red screen to flash upon% anticipatory responses:[w_width, w_height]=WindowSize(wdwPtr);antic_rect_X = [0; 0; w_width; w_width];antic_rect_Y = [0; w_height; w_height; 0];antic_rect = [antic_rect_X, antic_rect_Y];arrow_flag = 0;% 11/5/08: Now using the cue_type argument to determine whether to % plot a huge arrow on the screen:if strcmp(cue_type,'a')==1    arrow_flag = 1;    [w_width, w_height]=WindowSize(wdwPtr);    wH = 0.125*w_height;    wW = 0.125*w_width;    rightArrowX = [wW/4; wW/4; wW*5/8; wW*5/8; wW*7/8; wW*5/8; wW*5/8] + 0.5*w_width-0.5*wW;    rightArrowY = [5*wH/16; wH*11/16; wH*11/16; wH; wH/2; 0; 5*wH/16] + 0.5*w_height-0.5*wH;    rightArrow = [rightArrowX, rightArrowY];    leftArrow = [w_width-rightArrowX, w_height-rightArrowY];end% Need to make the dot motion random to decorrelate its direction from the% arrow direction. But that mean I'll also want to return the actual dot% motion on every trial, since it may not equal the value of ST now.if ~arrow_flag    rSet('dXdots',dotsIdx,'direction',direc,'visible',true);    rSet('dXtarget',targetIdx,'visible',true);    irrelevantMotionDir = direc;else    irrelevantMotionDir = 180*(rand(1) < 0.5);    rSet('dXdots',dotsIdx,'direction',irrelevantMotionDir,'visible',true);    rSet('dXpolygon',triangleIdx,'visible',true);end% rSet('dXtarget',targetIdx,'visible',true);rSet('dXtarget',blackTargetIdx,'visible',true);if arrow_flag%     rGraphicsDraw(500);    % 11/12/08: Draw for a fixed duration (initially, 500 msec on average), but     % allow early termination by a button press, followed by a penalty. You    % can tell whether a button was pressed by doing "find(myKeyCode)". The    % result should be NULL if no key was pressed, and non-NULL otherwise.    dot_onset_time = GetSecs;%     dot_duration = gamrnd(5,0.5/5); % Always need to make arrow onset%     unpredictable -- Now getting as an input argument%     timeS = GetSecs;    [ mySecs, myKeyCode ] = rGraphicsDrawSelectiveBreakMulti(dot_duration*1000,[],[lkey rkey]);    if ~isempty(find(myKeyCode,1))        % They pressed a key prematurely        premature_arrow = 1;        timeS = inf;    % The arrow will not even appear now    else        premature_arrow = 0;    end    dot_offset_time = mySecs; % Store this too, to see if premature            rGraphicsBlank;        if ~premature_arrow        if direc == 0            Screen('FillPoly', wdwPtr, [255 255 0], rightArrow);        else            Screen('FillPoly', wdwPtr, [255 255 0], leftArrow);        end        Screen('Flip', wdwPtr);        %     Screen('DrawingFinished', wdwPtr, 0);        %     KbWait;        %     mySecs = GetSecs;        %     myKeyCode = 29;        % record stim onset time to MEG file        if daq ~= -1            DaqDOut(daq, 0, 1);            DaqDOut(daq, 0, 0);        end        timeS = GetSecs;    % 11/12/08: Use this time after the arrow onset to define RT        while true            [ myKeyIsDown, mySecs, myKeyCode ] = KbCheckMulti;%             if myKeyIsDown%                 break;%             end            % 2/9/2009: Need to make sure I only look at presses            % of the left-response and right-response keys:            tmp_code = find(myKeyCode,1);            if ~isempty(tmp_code)                if tmp_code==lkey                    break                end                if tmp_code==rkey                    break                end            end            WaitSecs(0.001);        end    end%     [ mySecs, myKeyCode ] = rGraphicsDrawSelectiveBreak(inf,[],[29 16]);else    dot_onset_time = inf;    dot_duration = inf;    dot_offset_time = inf;        % record stim onset time to MEG file    if daq ~= -1        DaqDOut(daq, 0, 1);        DaqDOut(daq, 0, 0);    end    timeS = GetSecs;    [ mySecs, myKeyCode ] = rGraphicsDrawSelectiveBreakMulti(inf,[],[lkey rkey]);endtimeR = mySecs;% rDone;% return;% % rGraphicsBlank;rSet('dXdots',dotsIdx,'visible',false);% EK - try to set so that the fixation is always visible%if ~arrow_flag    rSet('dXtarget',targetIdx,'visible',true);%else%    rSet('dXpolygon',triangleIdx,'visible',true);%endrSet('dXtarget',blackTargetIdx,'visible',true);rGraphicsDraw;% Throwing in a check here to make sure that timeR is not less than % 100 msec. If so, incur a penalty and move to penalizing delay period, % returning the normal statistics that would've been returned (thus % the code that analyzes statistics should take care of RTs of < 100 % msec, by throwing those trials out). Currently this version of the % code does not return the number of premature presses.RT = timeR - timeS;% [keydown, secs, keycode] = KbCheck;% keynum = find(keycode);keynum = find(myKeyCode);if isempty (keynum)	keynum = 0;endER = (keynum(1) ~= corcode);% EK - record response time to MEG fileif daq ~= -1    % if valid response...    if ~premature_arrow        DaqDOut(daq, 0, 2);        DaqDOut(daq, 0, 0);    endend% Here's the 100 msec check:if RT > 0.1	score = scorein + ~ER;else	score = scorein;end% Get the particular direction of this trial:% if keynum == 7if keynum == lkey	RDir = 'L';% elseif keynum == 47elseif keynum == rkey	RDir = 'R';else	RDir = '-';endfeedback = 1;% 10/27/08: Now making a gamma-distributed RSI, with shape and mean% parameters sent by the calling function: scale = D/shape;RSI = gamrnd(shape,scale);if RT > 0.1 && ~premature_arrow        if ER        delay = RSI;        if ~arrow_flag            rSet('dXtarget',targetIdx,'color',contrast_factor*[255 0 0]);        else            rSet('dXpolygon',triangleIdx,'color',contrast_factor*[255 0 0]);        end        rGraphicsDraw;	elseif feedback        if ~arrow_flag            rSet('dXtarget',targetIdx,'color',contrast_factor*[0 255 0]);        else            rSet('dXpolygon',triangleIdx,'color',contrast_factor*[0 255 0]);                    end        rGraphicsDraw;        dur = makesound2(pahandle_correct);        delay = RSI - dur;	else        delay = RSI;	end	% Every 10 trials, display feedback for 0.5 seconds:    if (mod( ntrial, 5 ) == 1) && feedback        % 		TextCenter (windowptr, sprintf ('Score: %d', score), 0, 12);%         rGraphicsBlank;        rSet('dXdots',dotsIdx,'visible',false);        fontsize = 20;        str = sprintf ('Score: %d', score);        textwidth = fontsize*length(str)/ppd_;        x_pos = -0.3*textwidth;        rSet('dXtext',textIdx,'string',str,'visible',true,...            'x', x_pos, 'y', -1, ...            'size', fontsize);%         rAdd('dXtext', 1, 'visible', true, ...%         'x', x_pos, 'y', 0, ...%         'size', fontsize, ...%         'font', 'Courier',  ...%         'bold', true, ...%         'color', [1 1 1]*255, ...%         'string', str);% %         rGraphicsDraw(500);        rGraphicsDraw(delay);        % 		TextCenter (windowptr, sprintf ('Opponent: %d', opponent_score), 24, 12);% 		delay = max( delay, 0.5 );  % Ensure feedback of 0.5 seconds	endelse	% This is a penalty delay, so might as well make it big:    % Try flashing a red rectangle now:    Screen('FillPoly', wdwPtr, [255 0 0], antic_rect);    Screen('Flip', wdwPtr);	dur = makesound2(pahandle_antic);    Screen('FillPoly', wdwPtr, [0 0 0], antic_rect);	delay = 4 - dur;    rGraphicsDraw;    % That's no penalty at all for longer RSIs, so now double the average    % RSI to get a penalty delay (2/9/2009):    scale = D/shape;    delay = 2*gamrnd(shape,scale) - dur;    endif ~arrow_flag    rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);else    rSet('dXpolygon',triangleIdx,'color',contrast_factor*[255 255 255]);endpremie_t = []; premie_d = [];% 2/10/2009: Getting bizarre anticipatory response warnings whenever an% error is made, but ONLY when a second keyboard is plugged in. It may be% that KbCheck without using KbCheckMulti doesn't absorb continuous key% pressing:% 5/3/06: Soak up any continuous button pressing and don't do anything during such a time:% while KbCheckwhile KbCheckMulti    WaitSecs(0.001);end% Get a current time for the offset of the subject's keypress:start = GetSecs;% Wait for the RSI to expire. If it does, return. If it doesn't, go to the premie keypress % code below:% 2/9/2009: Scanner triggers are tripping this anticipatory response code,% so do a SELECTIVE KbCheckMulti:[ myKeyIsDown, mySecs, myKeyCode ] = KbCheckMulti;% while ~KbCheckwhile 1    tmp_code = find(myKeyCode,1);    if ~isempty(tmp_code)        if tmp_code==lkey            break        end        if tmp_code==rkey            break        end    end    % while isempty(KbName(myKeyCode)) || (KbName(myKeyCode)~=lkey && KbName(myKeyCode)~=rkey)	s = GetSecs - start;    WaitSecs(0.001);	if s >= delay%         rDone;            rGraphicsBlank;		return    end    [ myKeyIsDown, mySecs, myKeyCode ] = KbCheckMulti;end% If the function gets to here, then they made a premature keypress, % so penalize them:% dur = makesound;% 	start = GetSecs;% 9/14/05: Could determine inter-premature-press interval here:% premie_t = []; premie_d = [];% 5/3/06: make delay 4 seconds:s = GetSecs;% This is a penalty delay, so might as well make it big:% dur = makesound('errorsound');Screen('FillPoly', wdwPtr, [255 0 0], antic_rect);Screen('Flip', wdwPtr);dur = makesound2(pahandle_antic);Screen('FillPoly', wdwPtr, [0 0 0], antic_rect);rGraphicsDraw;delay = 4 - dur;% That's no penalty at all for longer RSIs, so now double the average% RSI to get a penalty delay (2/9/2009):scale = D/shape;delay = 2*gamrnd(shape,scale) - dur;premie_t = [premie_t, s - start];start = s;keynum = find(myKeyCode);if isempty (keynum)	keynum = 0;end% if keynum == 7if keynum == lkey	premie_d = [premie_d,'L'];% elseif keynum == 47elseif keynum == rkey	premie_d = [premie_d,'R'];else	premie_d = [premie_d,'-'];endwhile 1% 	n = 0.1 * randn( 1 );% 	if n < -D% 		n = -D + 0.01;% 	end	% Empty loop to absorb continuous pressing:    % 3/3/2009: I think the following KbCheckMulti, which was until just    % now a KbCheck, was the source of the infrequent anticipatory    % responses caused by the scanner trigger. 	while KbCheckMulti		WaitSecs(0.001);    end    [ myKeyIsDown, mySecs, myKeyCode ] = KbCheckMulti;    % 	while ~KbCheck    while 1        tmp_code = find(myKeyCode,1);        if ~isempty(tmp_code)            if tmp_code==lkey                break            end            if tmp_code==rkey                break            end        end%     while isempty(KbName(myKeyCode)) || (KbName(myKeyCode)~=lkey && KbName(myKeyCode)~=rkey)		s = GetSecs - start;        WaitSecs(0.001);		if s >= delay            %             rDone;            rGraphicsBlank;            			return        end        [ myKeyIsDown, mySecs, myKeyCode ] = KbCheckMulti;	end	% 	dur = makesound;		% 	start = GetSecs;	% 9/14/05: Could determine inter-premature-press interval here:	s = GetSecs;	% This is a penalty delay, so might as well make it big:% 	dur = makesound('errorsound');    Screen('FillPoly', wdwPtr, [255 0 0], antic_rect);    Screen('Flip', wdwPtr);    dur = makesound2(pahandle_antic);    Screen('FillPoly', wdwPtr, [0 0 0], antic_rect);    rGraphicsDraw;	delay = 4 - dur;    % That's no penalty at all for longer RSIs, so now double the average    % RSI to get a penalty delay (2/9/2009):    scale = D/shape;    delay = 2*gamrnd(shape,scale) - dur;% 	premie = s - start;	premie_t = [premie_t, s - start];	start = s;	keynum = find(myKeyCode);	if isempty (keynum)		keynum = 0;	end% 	if keynum == 7	if keynum == lkey		premie_d = [premie_d,'L'];% 	elseif keynum == 47	    elseif keynum == rkey		premie_d = [premie_d,'R'];	else		premie_d = [premie_d,'-'];	endend