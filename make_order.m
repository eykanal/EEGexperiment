function make_order();% make_order() creates a file that keeps track of the order of the super % and subblocks of the experiment. It creates a suitable ordering, and % also marks the last ordering used.% % 5/3/06: Changing to randomizing a string of 12 conditions.Bias = [ 0.5, 0.6, 0.75, 0.9 ];Delay = [ 0.5, 1, 2 ];% Create a list of every possible combination of bias or delay conditions:cond_itr = 0;for b = 1 : length(Bias)	for d = 1 : length(Delay)		cond_itr = cond_itr + 1;		Condition(cond_itr,:) = [ Bias(b), Delay(d) ];	endend% keyboard% Get a random permutation of a vector of indices from 1-12:Vector = [1:length(Bias)*length(Delay)];Vector2 = []; for i = 1:length(Bias)*length(Delay)	idx = round( rand(1)*length(Vector) );	Vector2=[Vector2,Vector(idx)];	Vector(idx) = [];end% Now a permutation exists in Vector2. For each subject, save the particular % ordering. There should be a unique permutation for each session for each % subject. The odds of generating two identical permutations are extremely % small. For that reason, you can generate the permutations on the fly before % each session. Then you can just save them at the start of each session.% Bias.val = [ 0.6,0.6,0.6,0.6, 0.75,0.75,0.75,0.75, 0.9,0.9,0.9,0.9; ...% 	0.6,0.6,0.6,0.6, 0.9,0.9,0.9,0.9, 0.75,0.75,0.75,0.75; ...% 	0.75,0.75,0.75,0.75, 0.6,0.6,0.6,0.6, 0.9,0.9,0.9,0.9; ...% 	0.75,0.75,0.75,0.75, 0.9,0.9,0.9,0.9, 0.6,0.6,0.6,0.6; ...% 	0.9,0.9,0.9,0.9, 0.6,0.6,0.6,0.6, 0.75,0.75,0.75,0.75; ...% 	0.9,0.9,0.9,0.9, 0.75,0.75,0.75,0.75, 0.6,0.6,0.6,0.6 ];	Bias.val = [ 0.6,0.6,0.6,0.6, 0.75,0.75,0.75,0.75, 0.9,0.9,0.9,0.9; ...	0.75,0.75,0.75,0.75, 0.9,0.9,0.9,0.9, 0.6,0.6,0.6,0.6; ...	0.9,0.9,0.9,0.9, 0.6,0.6,0.6,0.6, 0.75,0.75,0.75,0.75; ...	0.75,0.75,0.75,0.75, 0.6,0.6,0.6,0.6, 0.9,0.9,0.9,0.9; ...	0.6,0.6,0.6,0.6, 0.9,0.9,0.9,0.9, 0.75,0.75,0.75,0.75; ...	0.9,0.9,0.9,0.9, 0.75,0.75,0.75,0.75, 0.6,0.6,0.6,0.6 ];	Bias.startrow = 1;% New in CritDelayCompetitive (11/5/2004) -- allowing for incrementing % the starting point after wraparound:Bias.cycle_startrow = 1;% 9/15/05:% a = 0.3; b = 1; c = 2; % The intertrial delays useda = 0.5; b = 1; c = 2; % The intertrial delays used% 3 x 3 latin square design:Delay.val = ...	[ a b c c b c c a c c a b; ...	a c c b b a c c c c b a; ...	b a c c c c b a a c c b; ...	b c c a c c a b a b c c; ...	c c a b a b c c b c c a; ...	c c b a a c c b b a c c; ...	a b c c c c a b b c c a; ...	b a c c a c c b c c b a; ...	c c b a b a c c a c c b; ...	c c a b b c c a a b c c; ...	b c c a a b c c c c a b; ...	a c c b c c b a b a c c ];Delay.startrow = 1;Delay.cycle_startrow = 1;  % This is the row that gets incremented for next 							% cycle of delays.TotalUpdates = 0;   % Number of total accesses of the order file;							% save Bias;% save Delay;save OrderFile Bias Delay TotalUpdates;