function [ST, irrelDir, ST_time, arrow_onset, arrow_duration, ...    arrow_offset, RT, ER, RDir, PiDirbl, score, premie_t, premie_d ] = ...block (D, RSI_poss, shape, coher, coherence_array, cue_type, blockdur, ...    dotsIdx, targetIdx, triangleIdx,blackTargetIdx, textIdx_Score, ppd_,...    lkey, rkey, money, salary, wdwPtr, pahandle_correct, pahandle_antic,...    daq,contrast_factor,RT_struct)% function [ST, irrelDir, ST_time, arrow_onset, arrow_duration, ...%     arrow_offset, RT, ER, RDir, PiDirbl, score, premie_t, premie_d ] = ...% block (D, RSI_poss, shape, coher, coherence_array, cue_type, blockdur, ...%     dotsIdx, targetIdx, triangleIdx,blackTargetIdx, textIdx_Score, ppd_,...%     lkey, rkey, money, salary, wdwPtr, pahandle_correct, pahandle_antic,...%     daq,contrast_factor,RT_struct)%     block (D, RSI_poss,shape, coher, coherence_array,cue_type, blockdur, ...%     dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...%     wdwPtr, pahandle_correct, pahandle_antic, daq,contrast_factor,RT_struct)%%% Block of experiment% Inputs:%  coher - coherence of dots%  blockdur - duration of the block in seconds%  lkey - correct key for dots moving left%  rkey - correct key for dots moving right%  D - Response Stimulus Interval% %  Dpen - Additional Delay after making an error% Outputs: vectors as long as number of trials%  ST - sequnece of stimuli: 0 - small number of stars, 1 - high number of stars%  RT - reaction times [in seconds]%  ER - errors during trials: error = 1, correct = 0%  score - amount of points earned at the end of the trial%  opponent - amount of points earned by imaginary opponent%% PI -- bias in favored direction% 2/19/04: RDir is a new variable that records the actual leftward and rightward % responses for each trial.%% 11/8/04: SubScore and OppScore are running tallies of subject and opponent score % at the end of each trial.  % % 9/15/05: Eliminating feedback in one of three blocks for each delay in the % unbiased sessions, based on 'feedback'. Also, eliminating competitor.%% 5/3/06: Returning the timestamp of each stimulus onset now.timeSt = GetSecs;ntrial = 0;% 2/19/04: Adding a randomization of the direction favored by bias, so that it % isn't always toward the right:biasdir = rand(1);if biasdir < 0.5    PiDirbl = 'R';else	PiDirbl = 'L';end% timeSt = GetSecs;% PreCoherenceTime = GetSecs;if strcmp(cue_type,'a') == 1    rSet('dXdots',dotsIdx,'coherence',0);    rSet('dXtarget',targetIdx,'penWidth',1,'diameter',0.5);    arrow_flag = 1;else    rSet('dXtarget',targetIdx,'penWidth',24,'diameter',0.3);    rSet('dXdots',dotsIdx,'coherence',coher);    arrow_flag = 0;end% rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);% PostCoherenceTime = GetSecs;% 10/28/07: Just set PI to 0.5:PI = 0.5;score = 0;% Need an initial delay before first trial:% 10/27/08: Now making a gamma-distributed RSI, with shape and mean% parameters sent by the calling function: scale = D/shape;RSI = gamrnd(shape,scale);rGraphicsBlank;rSet('dXtarget',targetIdx,'visible',true);rSet('dXtarget',blackTargetIdx,'visible',true);rGraphicsDraw;WaitSecs(RSI);% In order to help randomly select RTs from arrows and dots trials in a% loaded file of RTs (if such a file is supplied by the user), compute% lengths of relevant RT arrays now, rather than inside the while loop% below. if arrow_flag & exist('RT_struct','var')    fast_low_dots_length    = length(RT_struct.fast_low_dots_RT);    fast_high_dots_length   = length(RT_struct.fast_high_dots_RT);    slow_low_dots_length    = length(RT_struct.slow_low_dots_RT);    slow_high_dots_length   = length(RT_struct.slow_high_dots_RT);    fast_arrow_length       = length(RT_struct.fast_arrow_RT);    slow_arrow_length       = length(RT_struct.slow_arrow_RT);end% MAIN TRIAL-CALLING LOOP:while GetSecs - timeSt < blockdur% for i = 1 : length(timing_row)    ntrial = ntrial + 1;       if biasdir < 0.5        ST_bool = (rand(1) < PI);    else        ST_bool = (rand(1) > PI );    end    if arrow_flag        if ~exist('RT_struct','var') | isempty(RT_struct)            dot_duration = gamrnd(5,0.5/5);        else            if D == RSI_poss(1)                if coher == coherence_array(1)                    % Randomly select a dot duration during arrow trials                    dots_idx     = ceil(rand(1)*fast_low_dots_length);                    arrow_idx    = ceil(rand(1)*fast_arrow_length);                    dot_duration = RT_struct.fast_low_dots_RT(dots_idx) - RT_struct.fast_arrow_RT(arrow_idx);                elseif coher == coherence_array(2)                    dots_idx     = ceil(rand(1)*fast_high_dots_length);                    arrow_idx    = ceil(rand(1)*fast_arrow_length);                    dot_duration = RT_struct.fast_high_dots_RT(dots_idx) - RT_struct.fast_arrow_RT(arrow_idx);                end            elseif D == RSI_poss(2)                if coher == coherence_array(1)                    dots_idx     = ceil(rand(1)*slow_low_dots_length);                    arrow_idx    = ceil(rand(1)*slow_arrow_length);                    % Randomly select a dot duration during arrow trials                    dot_duration = RT_struct.slow_low_dots_RT(dots_idx) - RT_struct.slow_arrow_RT(arrow_idx);                elseif coher == coherence_array(2)                    dots_idx     = ceil(rand(1)*slow_low_dots_length);                    arrow_idx    = ceil(rand(1)*slow_arrow_length);                    dot_duration = RT_struct.slow_high_dots_RT(dots_idx) - RT_struct.slow_arrow_RT(arrow_idx);                end            end                        % prevent the dot duration from going negative            if dot_duration < 0.200                dot_duration = 0.200;            end            if dot_duration > 2                dot_duration = 2;            end        end            else       dot_duration = inf;    end       if ST_bool        [RT(ntrial), ER(ntrial), RDir(ntrial), score, premie_t{ntrial}, ...            premie_d{ntrial}, ST_time(ntrial), arrow_onset(ntrial), ...            arrow_duration(ntrial), arrow_offset(ntrial), ...            irrelDirNumerical ] ...        = trial_arrow (dotsIdx, targetIdx, triangleIdx,blackTargetIdx, ...            textIdx_Score, ppd_, 0, rkey, lkey, rkey, D, shape, score, ...            ntrial, money, salary,wdwPtr, cue_type, pahandle_correct, ...            pahandle_antic, daq,contrast_factor,0,dot_duration);        ST(ntrial) = 'R';    else        [RT(ntrial), ER(ntrial), RDir(ntrial), score, premie_t{ntrial}, ...            premie_d{ntrial},ST_time(ntrial), arrow_onset(ntrial), ...            arrow_duration(ntrial), arrow_offset(ntrial), ...            irrelDirNumerical ] ...        = trial_arrow (dotsIdx, targetIdx, triangleIdx,blackTargetIdx, ...            textIdx_Score, ppd_, 180, lkey, lkey, rkey,D, shape, score, ...            ntrial, money, salary, wdwPtr, cue_type, pahandle_correct, ...            pahandle_antic, daq, contrast_factor, 0, dot_duration);        ST(ntrial) = 'L';    end        % Keep track of direction of irrelevant motion on arrow trials    % (equals actual motion direction on motion trials):    if irrelDirNumerical == 0        irrelDir(ntrial) = 'R';    else        irrelDir(ntrial) = 'L';    end    %    % Break out of loop if the last trial would've extended the block    %    % duration past its limit:    %    if terminate_flag    %        break    %    endend