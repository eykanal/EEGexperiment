function money = experiment (subject, Behavioral, RTfile)% 7/12/08: This is a first-pass attempt at a fixed viewing-time fMRI design% in which five 30 second mini-blocks each of a fixed coherence (one of% five% possible levels), are counterbalanced within roughly 4 minute runs. Each% trial has a fixed viewing time of 500 msec, and each trial is separated% by a jittered ISI of 1, 2 or 3 TRs, with a TR of 2 seconds, and with a% probability for each ISI that best approximates an exponential% distribution with mean equal to 4 seconds. Thus, at roughly five seconds% per trial (ISI+viewing time), we figure we can get about six trials per% miniblock. With five runs, this gives us roughly 30 trials at each% coherence level.%% Each trial consists of the onset of a moving dots stimulus, followed by% freezing. There will always be a fixation point in the middle. As soon as% the dots stop moving, the participant is supposed to press a right or% left button indicating whether right or left motion was observed. If they% are correct, the fixation circle turns Green; if they are incorrect, it% turns Red.%% Between trials, during the ISI period, a static dot pattern is displayed,% so that BOLD responses to the luminance and stuff can be subtracted out.% I'm not entirely sure that's a fully legitimate control condition, but% it's what the Kastner lab used or uses.%% After every miniblock, the total score (number correct) is displayed in% the center of the screen.%% This program spits out the times at which stimulus onsets occur. These% are jittered, so we need a record of the onset times in order to% correctly implement regressors for fMRI analysis. We of course all need a% record of left & right button presses.%%% MAJOR REVISION:%% 9/24/08: This is a first-pass at a free-response -- not fixed-viewing --% fMRI design. It consists of the following:%% 1) 2-minute blocks, approximately. This will allow for adaptation of DDM% parameters based on experience, and we can still throw out the first 5% trials of a block if necessary. 30 sec rest between blocks, and 15% seconds before the first block and after the last block for 10 minute% runs.%% 2) 12 conditions: factorially covarying coherence (3 levels), salient-cue% or not (2 levels), and 2 levels of some other variable, such as RSI, or% level of asymmetry in rewards or prior probabilities for left vs. right% stimuli.%% 3) 4 blocks per scanner-run, counterbalanced%% 4) 6 runs per experimental session, for a total of 60 minutes.%% 5) RSIs will be selected from a pseudo-exponential distribution, and% since we won't know how many trials will fit into a block, we will have% to make a choice about how to end blocks. At each trial, compute the new% RSI, plus 2 sec for a maximal RT. If that's within the time% limit of the block, present the stimulus. If not, then just wait out the% end of the block. Now, if the stimulus is presented but the block% duration times out, and the participant still hasn't responded, just cut% off the stimulus, and don't record a response. Otherwise, we could get% into serious timing difficulties. %% 10/27/08: Leigh was concerned about four-block runs, and we set up% 8-block runs along with the necessary counterbalancing. But that leads to% 20-minute runs, 3 per scan session, and Mike was taken a little bit taken% aback by that. I would like to insert prompts after each 30 second rest% period to allow the subject to control when the next block starts, but I% think Leigh thinks that that will cause possible problems. They can't% talk to us anyway during a run. Nevertheless, just the smallest amount of% interaction would be enough to help me if I was starting to feel trapped.% For now, code up for 8-block/2-minute runs with 30-sec interspersed rest,% and add the participant-control prompt later.%% 11/30/08: Adding the input parameter "Behavioral" to determine whether% this code is set up for behavioral testing (1), which prints% instructions to the screen that don't appear in the fMRI version. (0)% eliminates the instructions.% Default to fMRI settings if no behavioral flag set in the input params:if nargin < 2    Behavioral = 0;end% Before doing anything, let the user confirm that this subject number is% the right one:fprintf( 1, '\n The following information relating to subject %d currently exists: \n\n', subject );% Read in all the files related to subject:d = dir;indices = strmatch( sprintf( 'subject%d_', subject ), { d(:).name } );if isempty( indices )    fprintf( 1, 'New subject: no files related to subject %d in the directory. \n\n', subject );else    for i = 1 : length(indices)        fprintf( 1, '%s\t\t%s\n', d(indices(i)).name, d(indices(i)).date );    endenduser_comment = input('\nDo you want to enter a comment on this run? Answer will be saved as a string. Press return if no comment desired.\n','s');longRSI_override = input('\nDo you want to set all RSI''s to the long value? Type ''y'' if yes, ''n'' if no.\n', 's');coherence_array_override = input('\nDo you want to override the coherences? Enter a 2-element array of coherences if so, or return if not:\n');% coherence_array_override should be empty if no override is desiredcontinue_response = input( '\nContinue? Type ''y'' if yes, ''n'' if no.\n', 's' );if strcmp( continue_response, 'y' ) ~= 1    return    % 7/18/08: Not allowing this right now -- using a range of fixed    % coherences:    % else    % 	coherence_response = input( '\nDo you want to change the coherence? Type ''y'' or ''n''.\n', 's' );    % 	if strcmp( coherence_response, 'y' ) == 1    % 		coherence = input( '\nEnter a coherence value, from 0 to 256 -- 110 is difficult: \n' );    % 		coherence_flag = 1;    % 	else    % 		%coherence = 110;    % 		coherence_flag = 0;    % 	endend% 11/5/08: Not doing the following stuff anymore . . .% Now a permutation exists in Vector2. For each subject, save the particular% ordering. There should be a unique permutation for each session for each% subject. The odds of generating two identical permutations are extremely% small. For that reason, you can generate the permutations on the fly before% each session. Then you can just save them at the start of each session.fid = fopen( sprintf('subject%d_order.mat', subject) );if fid == -1    subj_order_file = sprintf( 'subject%d_order', subject );    SessionsCompleted = 0;%     % 	PIbl = PI_vals( SessionsCompleted, : );%     % 	Dbl = D_vals( SessionsCompleted, : );%     PIbl = Condition( 1, Permutation );%     Dbl = Condition( 2, Permutation );%     PermutationList = Permutation;else    fclose( fid );    % Order file already exists, so use it%     PIbl = Condition( 1, Permutation );%     Dbl = Condition( 2, Permutation );%     subj_order_file = sprintf( 'subject%d_order', subject );    load( subj_order_file );%     % The above line will load the current SessionsCompleted value and also the%     % current value of a variable named PermutationList.%     PermutationList = [PermutationList; Permutation];% %     if SessionsCompleted >= 10%         fprintf( 1, 'Already completed 10 sessions for subject %d.\n', subject );%         return%     end% % %     % Do this updating to the subject order file at the end of the experiment:%     % 	SessionsCompleted = SessionsCompleted + 1;%     % 	save( subj_order_file );% end% In this experiment, we're covarying two RSI levels, two motion coherence% levels, and two trial types (1: normal dot-motion discrimination; 2:% cued-response with a salient arrow cue, dot-motion is irrelevant)RSI_poss = [ 2 4 ];      % Mean RSI ("poss" means possibility)  % THESE ARE ASSUMED BELOW TO BE IN INCREASING MAGNITUDE ORDERShape_poss = [ 5 10 ];   % Gamma pdf shape parameter for individual RSI (scale = mean/shape)if isempty(coherence_array_override)coherence_array = [ 3 8 ];  % Coherence levels: 3 should be hard, 8 should be easier                            % THESE ARE ASSUMED BELOW TO BE IN INCREASING                            % MAGNITUDE ORDERelse    coherence_array = coherence_array_override;end% % For debugging:% RSI_poss = [ 2 3 ];      % Mean RSI ("poss" means possibility)% Shape_poss = [ 5 10 ];   % Gamma pdf shape parameter for individual RSI (scale = mean/shape)% coherence_array = [ 50 25 ];  % Coherence levels: 3 should be hard, 8 should be easier% coherence_array = [ 6 12 ];% 2/3/2009: Mike Arcaro was doing the above task conditions for 4 sessions% (subject72). For me, this was a little too easy. So I'll try coherences% of 3 and 8. As for the reduction from RSI of 4 to 3 seconds, I guess that% was to be sure to get greater numbers of trials per 2 minute block. You% can only get about 25 trials with shape 10 and mean RSI 4, whereas you% can get about 3 with shape 10 and mean 3. So I'll stick with 3 for now.% But I also (temporarily) change cue-type to all-dots below.% coherence_array = [ 3 8 ];% % 2/4/2009: Uncomment following line to double the coherences:% coherence_array = [ 6 16 ];% Leigh didn't like my previous scheme, since it can fall prey to agressive% high-pass filtering (with a really high lower-frequency cutoff). So we% now pick two variations on an RSI ordering, two variations on a coherence% ordering, and two variations on a cue-type ordering. Then we are free to% mix together one ordering of each, for 8 unique condition orderings. % RSI order: A B B A B A A B; or B A A B A B B A% Coherence order: C D C D D C D C; or D C D C C D C D % Cue order: E F F E E F F E; or F E E F F E E FRSIs = [ RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2); ...    RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) ];Shapes = [ Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2); ...    Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) ];Cohs = [ coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) ...    coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1); ...    coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1) ...    coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) ];Cues = [ 'd' 'a' 'a' 'd' 'd' 'a' 'a' 'd'; ...    'a' 'd' 'd' 'a' 'a' 'd' 'd' 'a' ];    % 'd': dots; 'a': arrow% 2/9/2009: Allow overriding the RSI settings to produce all long RSIs:if strcmp(longRSI_override,'y')==1    RSIs = [ RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2); ...        RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) RSI_poss(2) ];    Shapes = [ Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2); ...        Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) Shape_poss(2) ];end% % 2/3/2009: Changing cues to all-dots for RT collection. TEMPORARY.% Cues = [ 'd' 'd' 'd' 'd' 'd' 'd' 'd' 'd'; ...%     'd' 'd' 'd' 'd' 'd' 'd' 'd' 'd' ];    % 'd': dots; 'a': arrow% if Behavioral%     % For behavioral sessions, just use all dots trials:%     Cues = ['d','d','d','d','d','d','d','d';%         'd','d','d','d','d','d','d','d' ];% end% Now just pick a value of 1 or 2 for each of these features:RSI_row = floor(rand(1)+1.5);Coh_row = floor(rand(1)+1.5);Cue_row = floor(rand(1)+1.5);% The next lines isolate one row from the above data structures. These can% be indexed by the block-number in the main experiment loop below.RSI = RSIs(RSI_row,:);Shape = Shapes(RSI_row,:);coherence = Cohs(Coh_row,:);cue_type = Cues(Cue_row,:);salary = 1;					%money earned by subjects for correct decision [in cents]salary = 2;             % 2/9/2009: Need to boost earnings for slower RSIs% keys = ['Z', 'M'];			%keys used for responses% 7/18/08: Scanner's button box uses numeral keys. 6 and 9 encode pinky and% forefinger buttons on the Left (I think) button box. Or else right. The% other shift-characters are needed too to identify the key: '6^' and '9('.% keys = [ KbName('6^'), KbName('9(') ];% % 10/27/08: Now using behavioral keys:% keys = [ KbName('Z'), KbName('M') ];if Behavioral    blockdur = 240;				%duration of a single block in seconds (4 min for Behavioral)    waitdur = 30;               % Should not be relevant for Behavioral sessions    % For debugging:    blockdur = 10;    waitdur = 2;    keys = [ KbName('Z'), KbName('M') ];    else    blockdur = 120; % 2-minute blocks (for fMRI)    waitdur = 30;   % 30 second blank period        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % LEIGH: COMMENT OUT NEXT TWO LINES    % For debugging:    blockdur = 10;    waitdur = 2;%     blockdur = 30;%     waitdur = 10;    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%        % keys = [ KbName('6^'), KbName('9(') ];    keys = [ KbName('9('), KbName('6^') ];  % 2/4/2009: Inverting mapping for new button box, which you have to hold upside downend% 2/4/2009: Load up a datafile of RTs for determining arrow onset times, or% create fake data to serve the same purpose.% This file is expected to contain all the variables saved by this% function. Then for each arrow block, I select arrow onset times from% a distribution of RTs in one of the dots conditions. However, I need% to subtract a residual latency from this RT, so that RT distributions% in the dots and arrows conditions are similar. The question is, what% exactly to subtract. My first guess is to select a non-decision% latency from the distribution of signal detection RTs. But in fact,% probably I should select from the RTs in the arrow trials in blocks% with equivalent RSIs.if nargin > 2   % Check to make sure there IS an RTfile    load(RTfile);    % BE CAREFUL! If you load all the same variables that are used in this    % function, everything will get screwed up. So the RT file should store    % variables with different names, which can be done by a    % post-processing step after the original data is collected. This will    % require RTs for every one of the 4 dots conditions, and every one of    % the 4 arrow conditions (really 2, since coherence is 0 in those    % blocks). We'll want one RT for each block, along with an identifier    % of RSI, coherence, and cue-type. Well, if desired, we can just do the    % extraction of these subtypes from the RTfile.    % OK, adding a "_t" to the end of all relevant variables.    RT_struct.fast_arrow_RT = RT_t(find(D_t==RSI_poss(1) & CueType_t=='a'));    RT_struct.slow_arrow_RT = RT_t(find(D_t==RSI_poss(2) & CueType_t=='a'));    % This collapses over coherence during arrow trials, which is likely to    % be 0, although it was not for some of my own behavioral sessions.    RT_struct.fast_low_dots_RT = RT_t(find(D_t==RSI_poss(1) & CueType_t=='d' & TrialCoh_t==coherence_array(1)));    RT_struct.fast_high_dots_RT = RT_t(find(D_t==RSI_poss(1) & CueType_t=='d' & TrialCoh_t==coherence_array(2)));    RT_struct.slow_low_dots_RT = RT_t(find(D_t==RSI_poss(2) & CueType_t=='d' & TrialCoh_t==coherence_array(1)));    RT_struct.slow_high_dots_RT = RT_t(find(D_t==RSI_poss(2) & CueType_t=='d' & TrialCoh_t==coherence_array(2)));else    % Make fake data using a gamma distribution with mean decision time    % = 800 msec, and mean signal detection time = 300 msec:    RT_struct.fast_arrow_RT = normrnd(0.35,0.05*ones(1,1000));    RT_struct.slow_arrow_RT = normrnd(0.35,0.05*ones(1,1000));    % This collapses over coherence during arrow trials, which is likely to    % be 0, although it was not for some of my own behavioral sessions.    RT_shape = 5;    RT_scale = 0.8/5;    RT_struct.fast_low_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.fast_high_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.slow_low_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.slow_high_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));end% checking existence of the datafile% filename = sprintf ('subject%d_ses%d.mat', subject, SessionsCompleted);filename = sprintf ('subject%d_ses%d.mat', subject, SessionsCompleted + 1);fid = fopen (filename, 'r');if fid ~= -1    fclose (fid);    data_exists_response = input ('\n\nA datafile for this subj/session already exists. Replace it (y/n)?\n', 's');    if strcmp( data_exists_response, 'n' ) || strcmp( data_exists_response, 'N' )        fprintf(1, '\n\nOK, then please run function experiment with another subject number.\n\n');        return    endend% continue_response = input( '\nContinue? Type ''y'' if yes, ''n'' if no.\n', 's' );lkey = keys(1);rkey = keys(2);rand ('state', sum(100*clock));randn ('state', sum(100*clock));% Initialize the USB device:devices = PsychHID('Devices');daq = DaqDeviceIndex;% % If you want to run this without the USB device, set daq to -1:daq = -1;% Encapsulate everything in a try-catch to get the screen back from PTB:% try% Screen('Preference','SkipSyncTests')% rInit('local'); % 7/16/07 -- shifting to DotsX coderInit({'screenMode', 'local', 'showWarnings', true});% Screen('Preference','SkipSyncTests')% 7/19/08: need access to the window pointer for freeze-framing dots.wdwPtr = rWinPtr;% % Get access to ROOT_STRUCT so it can be saved:% global ROOT_STRUCT;% % ROOT_STRUCT% 7/17/07: A bunch of PTB sound manipulation code needs to be initialized:% Perform basic initialization of the sound driver:InitializePsychSound;% Read WAV file from filesystem:% [y, freq, nbits] = wavread(wavfilename);expdir = fileparts(which('experiment_fMRI.m'));[y, freq, nbits] = wavread(fullfile(expdir,'SOUND16'));wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.% Open the default audio device [], with default mode [] (==Only playback),% and a required latencyclass of zero 0 == no low-latency mode, as well as% a frequency of freq and nrchannels sound channels.% This returns a handle to the audio device:pahandle_correct = PsychPortAudio('Open', [], [], 0, freq, nrchannels);% Fill the audio playback buffer with the audio data 'wavedata':PsychPortAudio('FillBuffer', pahandle_correct, wavedata);% Now open a channel for the anticipatory error sound:[y, freq, nbits] = wavread(fullfile(expdir,'errorsound'));wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.% Open the default audio device [], with default mode [] (==Only playback),% and a required latencyclass of zero 0 == no low-latency mode, as well as% a frequency of freq and nrchannels sound channels.% This returns a handle to the audio device:pahandle_antic = PsychPortAudio('Open', [], [], 0, freq, nrchannels);% Fill the audio playback buffer with the audio data 'wavedata':PsychPortAudio('FillBuffer', pahandle_antic, wavedata);% Also initialize the KbCheck routine:KbCheckMulti;                   % Initialize keyboard check routinetriggercode = KbName('1!');     % This actually needs to change to '!' for true scanner triggeringtriggercode = KbName('LEFTSHIFT');  % Nope, LEFTSHIFT instead of !% triggercode = 225;RT = [];bl = 1;% welcome5;score = 0;% Print text saying to hit some key to start, and then wait for trigger:% 7/17/07: Get the pixels-per-degree for DotsX:ppd_ = rGet('dXscreen', 1, 'pixelsPerDegree');fontsize = 20;font_degrees = 0.7;str = sprintf ('Press a button to start, then fixate on the central circle');%     textwidth = fontsize*length(str)/ppd_;%     textwidth = font_degrees*length(str)/ppd_;textwidth = font_degrees*length(str);x_pos = -0.3*textwidth;textIdx_Start = rAdd('dXtext', 1, 'visible', true, ...    'x', x_pos, 'y', 0, ...    'size', floor(font_degrees*ppd_), ...    'font', 'Courier',  ...    'color', [1 1 1]*255, ...    'string', str);rGraphicsDrawMulti(inf);rSet('dXtext',textIdx_Start,'visible',false);while KbCheckMulti; endrGraphicsDraw;% Wait for scanner trigger:while 1    %         while KbCheckMulti; end    [ keyIsDown, seconds, keyCode ] = KbCheckMulti;    %     [ keyIsDown, seconds, keyCode ] = KbCheck;    if keyIsDown        if keyCode(triggercode)            TriggerTime = GetSecs;            break        end    end    %         WaitSecs(0.02);end% Dots features from motion_localizer_translational.m:contrast_factor = 1;   % The percentage of 256 for color saturation (0.1 used in fixed-viewing version)blank_time = 1000;      % 1000 msec blank time at the endblank_time = 2000;blank_time = 10000;     % 2/9/2009: 10 second blank time at endpix_degree_size = 0.15;  % This sets pixels to .15 degrees visual angle for a given screenaperture_diam = 25;     % Degrees covered by apertureaperture_diam = 10;target_diam = 0.3;      % Degrees covered by targetblack_annulus_diam = 2;     % A black target behind the visible target for preventing dot-tracking at fixationpixelsize = floor(pix_degree_size * ppd_);density = 20;           % dots/degree^2 Downing-Movshon says dots/degree^2/sec -- I don't get why sec is relevantspeed = 7;              % Dot-speed in deg/secloops = 3;              % A low-level drawing feature of DotsX codemotion_dur = 500;       % Motion stimulus duration in msec (fixed viewing time)% The black target imitates the annulus idea in the Kastner lab motion% localizer code, presumably to prevent tracking of individual dots% that move through the fixation point.% Apparently, adding the triangle fixation point before the black target is% critical for having the triangle displayed on top of the black target (I% think). Interestingly, it's OK to add the circular white target AFTER the% black target to get the white target to show up.triangleIdx = rAdd('dXpolygon', 1, 'visible', false, ...        'color', contrast_factor*[255 255 255], ...        'pointList', 0.65*target_diam*[-1 1; 1 1; 0 -1]);blackTargetIdx = rAdd('dXtarget', 1, 'color', contrast_factor*[0 0 0],'penWidth',24,'diameter',black_annulus_diam,'visible',false);% add some dots and a targettargetIdx = rAdd('dXtarget', 1, 'color', contrast_factor*[255 255 255],'penWidth',24,'diameter',target_diam,'visible',false);dotsIdx = rAdd('dXdots', 1, 'color', contrast_factor*[255 255 255], 'direction',0,'coherence',coherence_array(1),...    'diameter',aperture_diam,'size',pixelsize,'loops',loops,'density',density,'speed',speed,'lifetimeMode','random', ...    'visible',false);% triangleIdx = rAdd('dXpolygon', 1, 'visible', false, ...%         'color', contrast_factor*[255 255 255], ...%         'pointList', target_diam*[-1 1; 1 1; 0 -1]);        % % %     rGraphicsDraw;% ROOT_STRUCT.dXtarget = draw(ROOT_STRUCT.dXtarget);% ROOT_STRUCT.dXdots = draw(ROOT_STRUCT.dXdots);% %     Screen('Flip', wdwPtr, [], 1)fontsize = 20;font_degrees = 0.7;str = sprintf ('Score: %d', score);%     textwidth = fontsize*length(str)/ppd_;textwidth = font_degrees*length(str);x_pos = -0.3*textwidth;textIdx_Score = rAdd('dXtext', 1, 'visible', false, ...    'x', x_pos, 'y', 0, ...    'size', floor(font_degrees*ppd_), ...    'font', 'Courier',  ...    'color', contrast_factor*[1 1 1]*255, ...    'string', str);RT = [];bl = 1;if Behavioral    welcome5;end% % Display score between blocks:% %         rSet('dXdots',dotsIdx,'speed',0);% rSet('dXtext',textIdx_Score,'string',sprintf('Score: %d', score),'visible',true);% rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);% % %         ROOT_STRUCT.dXdots = draw(ROOT_STRUCT.dXdots);% % ROOT_STRUCT.dXtarget = draw(ROOT_STRUCT.dXtarget);% % ROOT_STRUCT.dXtext = draw(ROOT_STRUCT.dXtext);% % Screen('Flip', wdwPtr, [], 1);% Using Rafal's names for trial-indexing of the returned data:% 'ib' refers to 'index beginning'% 'ie' refers to 'index end'% 'bl' is the block number% the main experimental loop% RT = [];money = 0;numblocks = length(RSI);for bl = 1 : numblocks    if Behavioral        resting_arrow (numblocks - bl + 1 + 2, money, cue_type(bl) );    else        resting_arrow_fMRI(numblocks - bl + 1, money, cue_type(bl), waitdur );    end            [STbl, irrelDirbl, ST_timebl, dot_onsetbl, dot_durbl, dot_offsetbl, RTbl, ERbl, RDirbl, PiDirbl, score, premie_t,premie_d] = ...		block_fMRI (RSI(bl), RSI_poss, Shape(bl), coherence(bl), coherence_array, cue_type(bl), blockdur, ...        dotsIdx, targetIdx, blackTargetIdx, triangleIdx, textIdx_Score, ppd_, lkey, ...		rkey, money, salary, ...        wdwPtr, pahandle_correct, pahandle_antic, daq, contrast_factor, Behavioral, RT_struct);	ib = length(RT) + 1;					%index of the begining of inserted block	ie = length(RT) + length(RTbl);	%index of the end of inserted block	ST(ib:ie) = STbl;    irrelDir(ib:ie) = irrelDirbl;   % Direction of irrelevant motion on arrow trials (will equal ST on motion trials)	ST_time(ib:ie) = ST_timebl;    dot_onset(ib:ie) = dot_onsetbl;    dot_dur(ib:ie) = dot_durbl;    dot_offset(ib:ie) = dot_offsetbl;	RT(ib:ie) = RTbl;	ER(ib:ie) = ERbl;	RDir(ib:ie) = RDirbl;	blocknum(ib:ie) = bl;	trialnum(ib:ie) = 1:length(RTbl);% 	D(ib:ie) = Dbl(bl-1);% 	PI(ib:ie) = PIbl(bl-1);    D(ib:ie) = RSI(bl);    TrialShape(ib:ie) = Shape(bl);    TrialCoh(ib:ie) = coherence(bl);    CueType(ib:ie) = cue_type(bl);    PI(ib:ie) = 0.5;	PiDir(ib:ie) = PiDirbl; % For 50:50 stimuli, this variable is meaningless	%    Dpen(ib:ie) = Dpenbl(bl);	% 9/19/05: Keeping track of premature responses with an array of cell arrays of time & direction vectors:	Premie_t(ib:ie) = premie_t;	Premie_d(ib:ie) = premie_d;		money = money + score * salary;        % While the following % 	save (filename);	endif Behavioral    % resting2 (windowptr, 2, money, opponent_money );    % resting (2, money);%     resting_arrow(numblocks - bl + 1 + 2, money, cue_type(bl) );    % Now add in two blocks that test signal detection speed, each of 2.5 minutes    % (leading to a total experiment time of 90 minutes):    sig_det_instruction(salary);    sig_det_resting( 2, money, 'Left' );    % 10/27/08: Using the lowest coherence for the signal detection tasks. No    % reason -- just have to pick one of the two currently being used.    % 5/3/06: Adapting block.m for sig_det_block.m:    % [Left_ST, Left_ST_time, Left_RT, Left_ER, score1, Left_premie_t, Left_premie_d] = ...    % sig_det_block (coherence_array(1), blockdur/2, lkey, ...    % rkey, 0.5, money, salary, 1, pahandle_correct, pahandle_antic,'Left',daq);    % money = money + score1 * salary;    [Left_ST, Left_ST_time, Left_RT, Left_ER, score1, Left_premie_t, Left_premie_d] = ...        sig_det_block(RSI_poss(1), Shape_poss(1), coherence_array(1), blockdur/2, 'Left', ...        dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...        pahandle_correct, pahandle_antic, daq, contrast_factor);    money = money + score1 * salary;    % sig_det_resting(1,money,'Right', windowptr );    sig_det_resting(1,money,'Right');    % [Right_ST, Right_ST_time, Right_RT, Right_ER, score2, Right_premie_t, Right_premie_d] = ...    % sig_det_block (coherence_array(1), blockdur/2, lkey, ...    % rkey, 0.5, money, salary, 1, pahandle_correct, pahandle_antic, 'Right',daq );    [Right_ST, Right_ST_time, Right_RT, Right_ER, score2, Right_premie_t, Right_premie_d] = ...        sig_det_block(RSI_poss(1), Shape_poss(1), coherence_array(1), blockdur/2, 'Right', ...        dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...        pahandle_correct, pahandle_antic, daq, contrast_factor);    money = money + score2 * salary;        % Finishing the experiment    save (filename, 'ST', 'ST_time', 'dot_onset', 'dot_dur', 'dot_offset', 'RT', 'ER', 'RDir', 'blocknum', 'trialnum', ...        'D', 'TrialShape','TrialCoh','CueType', 'PI', 'PiDir', 'money', ...        'Left_ST', 'Left_ST_time', 'Left_RT', 'Left_ER', 'Left_premie_t', 'Left_premie_d', ...        'Right_ST', 'Right_ST_time', 'Right_RT', 'Right_ER', 'Right_premie_t', 'Right_premie_d', ...        'Premie_t', 'Premie_d', 'contrast_factor',...        'blank_time', 'pix_degree_size', 'aperture_diam','pixelsize', ...        'target_diam','black_annulus_diam','ppd_','density','speed','loops', ...        'waitdur','blockdur','numblocks','Behavioral','user_comment');        rSet('dXdots',dotsIdx,'visible',false);    rSet('dXtarget',targetIdx,'visible',false);    rSet('dXtarget',blackTargetIdx,'visible',false);    rGraphicsDraw;    thankyou (money);else    save (filename, 'ST', 'ST_time', 'dot_onset', 'dot_dur', 'dot_offset', 'RT', 'ER', 'RDir', 'blocknum', 'trialnum', ...        'D', 'TrialShape','TrialCoh','CueType', 'PI', 'PiDir', 'money', ...        'Premie_t', 'Premie_d', 'contrast_factor',...        'blank_time', 'pix_degree_size', 'aperture_diam','pixelsize', ...        'target_diam','black_annulus_diam','ppd_','density','speed','loops', ...        'waitdur','blockdur','numblocks','Behavioral','user_comment','TriggerTime');        % thankyou (money)    % opponent_money = thankyou (money, opponent_money, score1+score2, salary, windowptr);    % money = 0; opponent_money = 0; salary = 0;    rSet('dXdots',dotsIdx,'visible',false);    rSet('dXtarget',targetIdx,'visible',false);    rSet('dXtarget',blackTargetIdx,'visible',false);    rGraphicsDraw;    thankyou_fMRI (money,blank_time/1000);end% Now update the subject order file. By doing this at the end of the% experiment, interrupted sessions are totally ignored, both from the% perspective of the individual subject's order file and for the master% order file that enables counterbalancing of conditions across subjects% and sessions. This means that starting an interrupted session over% again will repeat the block ordering for the subject. Assuming that% interruptions typically happen early in the session because the% experimenter realized he/she made a mistake, this is not too problematic.% But if a power failure happens near the end of a session, they will get% exactly the same ordering the next time they do the session -- but in% that case, the subject will almost certainly want to come back on% another day and will hopefully forget the ordering, so this seems the% best solution for the problem of interruptions.SessionsCompleted = SessionsCompleted + 1;% save( subj_order_file, 'PI_vals', 'D_vals', 'SessionsCompleted' );% save( subj_order_file, 'PermutationList', 'SessionsCompleted' );save( subj_order_file, 'SessionsCompleted' );rDone;% Close the audio device:PsychPortAudio('Close', pahandle_correct);PsychPortAudio('Close', pahandle_antic);return% catch%     Screen('CloseAll');%     %     psychrethrow(psychlasterror);%     rethrow(lasterror);%     PsychPortAudio('Close', pahandle_correct);%     PsychPortAudio('Close', pahandle_antic);%     FlushEvents;% end