function [ST, ST_time, RT, ER, score, premie_t, premie_d] = ...	block (coher, blockdur, lkey, rkey, D, money, opponent_money, salary, respdir,windowptr)% function [ST, RT, ER, score] = block (coher, blockdur, lkey, rkey, D, PI)%% Block of experiment% Inputs:%  coher - coherence of dots%  blockdur - duration of the block in seconds%  lkey - correct key for dots moving left%  rkey - correct key for dots moving right%  D - Response Stimulus Interval% %  Dpen - Additional Delay after making an error% Outputs: vectors as long as number of trials%  ST - sequnece of stimuli: 0 - small number of stars, 1 - high number of stars%  RT - reaction times [in seconds]%  ER - errors during trials: error = 1, correct = 0%  score - amount of points earned at the end of the trial%  opponent - amount of points earned by imaginary opponent%% PI -- bias in favored direction% 2/19/04: RDir is a new variable that records the actual leftward and rightward % responses for each trial.%% 11/8/04: SubScore and OppScore are running tallies of subject and opponent score % at the end of each trial.  % % 9/15/05: Eliminating feedback in one of three blocks for each delay in the % unbiased sessions, based on 'feedback'. Also, eliminating competitor.%% 5/3/06: Returning the timestamp of each stimulus onset now.PI = 0.5;feedback = 1;% rInit ('visible', 1);	%initializes screen and makes it visible% windowptr = screen('Windows');screen (windowptr, 'TextFont', 'Courier New');wartime = 5;		%how long should be the warning before the trial[rect] = screen (windowptr, 'Rect');SetMouse (rect(3), rect(4));for i = wartime:-1:1%    screen (windowptr, 'TextSize', 48);% 9/15/05:   screen (windowptr, 'TextSize', 36);   % 9/15/05:   if ~feedback	   TextCenter (windowptr, 'There will be no feedback in this block', -200, 12 );   end   TextCenter (windowptr, 'Get Ready', -100, 12);   TextCenter (windowptr, sprintf ('Block starts in %ds', i), 0, 12);   screen (windowptr, 'TextSize', 20);   TextCenter (windowptr, sprintf ('Remember: "%c" - left; "%c" - right', lkey, rkey), 200, 12);   WaitSecs(1);   screen (windowptr, 'FillRect', 255);endtimeSt = GetSecs;ntrial = 0;score = 0;opponent = 0;rAdd ('dots', [1], 'coherence', coher, 'diameter', 56);	% Creates an objects of dots% 2/19/04: Adding a randomization of the direction favored by bias, so that it % isn't always toward the right:biasdir = rand(1);if biasdir < 0.5	PiDirbl = 'R';else	PiDirbl = 'L';end% 5/2/06: Given a particular D value for mean RSI, compute a set of RSI values based on an % exponential density that has mean equal to D, as well as a rest or refractory period of % 400 msec, to let subjects regroup for the next trial. This requires solving for lambda in % the following equation:%% 1/lambda + 0.4 = D   ==>   lambda = 1/(D-0.4)%% Compute the bin boundaries for method 3 on p.76 of Luce, using 25 msec time increments % starting at 400 msec and going up to max possible RSI, by which point 99% of RSIs should % have elapsed: maxRSI = log(.01)/(-lambda):lambda = 1/(D-0.3);maxRSI = log(.01)/(-lambda) + 0.3;% Compute the half-percentiles of the exponential density with these parameters. First % compute a fine mesh approximation to the cumulative distribution of RSI over the % complete range of possible RSIs:F = [];for t = 0 : 0.001 : maxRSI - 0.3	F = [ F, 1 - exp(-lambda*t) ];end% Now look at a mesh of F values, and find which times correspond most closely to the % F-mesh points:t = [ 0 : 0.001 : maxRSI - 0.3 ];bin_bound(1) = 0;for q = 1 : 200	F_nearest_lower = F(find( F < q*(1/200) ));	if isempty(F_nearest_lower)		F_nearest_lower = 0;	end	F_nearest_upper = F(find( F > q*(1/200) ));	if isempty(F_nearest_upper)		F_nearest_upper = F(end);	end	F_nearest_lower = F_nearest_lower(end);	F_nearest_upper = F_nearest_upper(1);	% Now I could do some fancy interpolation here, but I'll keep it simple to limit any 	% need for debugging. Just take the nearest F value to the quantization value q:	if abs(F_nearest_lower - q*(1/200)) <= abs(F_nearest_upper - q*(1/200))		F_nearest = F_nearest_lower;	else		F_nearest = F_nearest_upper;	end% 	keyboard	bin_bound(q+1) = t( find(F == F_nearest) );end% Take midpoints of bins as the quantized RSI values (following Luce):for q = 1 : 200	RSI_vector(q) = 0.5*(bin_bound(q+1)+bin_bound(q));endRSI_vector = RSI_vector + 0.3;while GetSecs - timeSt < blockdur   ntrial = ntrial + 1;      if biasdir < 0.5	   ST_bool = (rand(1) < PI);   else	   ST_bool = (rand(1) > PI );   end   if ST_bool	   % Sept 14, 2005: Can also return a vector of times between succeeding premature responses 	   % if desired. premie_t is a cell array of premature response time vectors at each trial, 	   % and premie_d is the direction of those responses.% %       [RT(ntrial), ER(ntrial), RDir(ntrial), score, opponent] = trial (windowptr, 0, rkey, D, score, opponent, money, opponent_money, salary, ntrial);%       [RT(ntrial), ER(ntrial), RDir(ntrial), score, opponent,premie_t{ntrial},premie_d{ntrial}] = ...% 	  	trial (windowptr, 0, rkey, D, score, opponent, money, opponent_money, salary, ntrial,feedback);      [RT(ntrial), ER(ntrial), RDir(ntrial), score, opponent,premie_t{ntrial},premie_d{ntrial},ST_time(ntrial)] = ...	  	sig_det_trial_target (windowptr, 0, rkey, RSI_vector, score, opponent, money, opponent_money, salary, ntrial,feedback,respdir);	  ST(ntrial) = 'R';	  % Now store trial-by-trial scores:	  SubScore(ntrial) = score;	  OppScore(ntrial) = opponent;   else%       [RT(ntrial), ER(ntrial), RDir(ntrial), score, opponent] = trial (windowptr, 180, lkey, D, score, opponent, money, opponent_money, salary, ntrial);      [RT(ntrial), ER(ntrial), RDir(ntrial), score, opponent,premie_t{ntrial},premie_d{ntrial},ST_time(ntrial)] = ...	  	sig_det_trial_target (windowptr, 180, lkey, RSI_vector, score, opponent, money, opponent_money, salary, ntrial,feedback,respdir);	  ST(ntrial) = 'L';	  % Now store trial-by-trial scores:	  SubScore(ntrial) = score;	  OppScore(ntrial) = opponent;  end  % To wipe out the residual text characters that don't get wiped out by   % the presentation of dot stimuli:  screen (windowptr, 'FillRect', 255);endFlushEvents (['keydown']); 	%in order to avoid eating the key% rDone;					% turns off the screen and destroys all objectsscreen(windowptr,'FillRect',255);