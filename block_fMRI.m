function [ST, irrelDir, ST_time, dot_onset, dot_duration, dot_offset, RT, ER, RDir, PiDirbl, score, premie_t, premie_d ] = ...    block_fMRI (D, RSI_poss, shape, coher, coherence_array, cue_type, blockdur, ...    dotsIdx, targetIdx, blackTargetIdx, triangleIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...    wdwPtr, pahandle_correct, pahandle_antic, daq, contrast_factor, Behavioral, RT_struct)% contrast_factor, ppd_, target_diam, black_annulus_diam, pixelsize,% density, speed, loops, aperture_diam,% function [ST, RT, ER, score] = block (coher, blockdur, lkey, rkey, D, PI)%% 7/16/07: Converting this entirely to the DotsX code.%% Block of experiment% Inputs:%  coher - coherence of dots%  blockdur - duration of the block in seconds%  lkey - correct key for dots moving left%  rkey - correct key for dots moving right%  D - Response Stimulus Interval% %  Dpen - Additional Delay after making an error% Outputs: vectors as long as number of trials%  ST - sequnece of stimuli: 0 - small number of stars, 1 - high number of stars%  RT - reaction times [in seconds]%  ER - errors during trials: error = 1, correct = 0%  score - amount of points earned at the end of the trial%  opponent - amount of points earned by imaginary opponent%% PI -- bias in favored direction% 2/19/04: RDir is a new variable that records the actual leftward and rightward % responses for each trial.%% 11/8/04: SubScore and OppScore are running tallies of subject and opponent score % at the end of each trial.  % % 9/15/05: Eliminating feedback in one of three blocks for each delay in the % unbiased sessions, based on 'feedback'. Also, eliminating competitor.%% 5/3/06: Returning the timestamp of each stimulus onset now.% 11/5/08: Uncomment the following to get a countdown warning:%% wartime = 5;		%how long should be the warning before the trial% % [rect] = screen (windowptr, 'Rect');% % % PI = 0.5; % Always do 50/50 in a signal detection block.% % % % % 7/17/07: Get the pixels-per-degree for DotsX:% % ppd_ = rGet('dXscreen', 1, 'pixelsPerDegree');% % % feedback = 1;   % Always give feedback now% % % % fontsize = 36;% str = 'Get Ready';% textwidth = fontsize*length(str)/ppd_;% x_pos = -0.3*textwidth;% seconds_idx = rAdd('dXtext', 1, 'visible', true, ...%     'x', x_pos, 'y', 1, ...%     'size', fontsize, ...%     'font', 'Courier',  ...%     'bold', true, ...%     'color', [1 1 1]*255, ...%     'string', str);% % % str = sprintf ('Block starts in %d seconds', wartime);% textwidth = fontsize*length(str)/ppd_;% x_pos = [];% x_pos = -0.3*textwidth;% seconds_idx = rAdd('dXtext', 1, 'visible', true, ...%     'x', x_pos, 'y', 0, ...%     'size', fontsize, ...%     'font', 'Courier',  ...%     'bold', true, ...%     'color', [1 1 1]*255, ...%     'string', str);% % fontsize = 20;% str = [];% str = sprintf ('Remember: "%c" - left; "%c" - right', lkey, rkey);% textwidth = [];% textwidth = fontsize*length(str)/ppd_;% x_pos = [];% x_pos = -0.3*textwidth;% rAdd('dXtext', 1, 'visible', true, ...%     'x', x_pos, 'y', -2, ...%     'size', fontsize, ...%     'font', 'Courier',  ...%     'bold', true, ...%     'color', [1 1 1]*255, ...%     'string', str);% % rGraphicsDrawNoInterrupt(1000);% % % SetMouse (rect(3), rect(4));% for i = wartime-1:-1:1%     str = sprintf ('Block starts in %d seconds', i);% %     rSet('dXtext',seconds_idx,'string',str);%     rGraphicsDrawNoInterrupt(1000);% % end% % % rClear;% rGraphicsBlank;% timeSt = GetSecs;ntrial = 0;% 2/19/04: Adding a randomization of the direction favored by bias, so that it % isn't always toward the right:biasdir = rand(1);if biasdir < 0.5	PiDirbl = 'R';else	PiDirbl = 'L';end% timeSt = GetSecs;% PreCoherenceTime = GetSecs;if strcmp(cue_type,'a') == 1    rSet('dXdots',dotsIdx,'coherence',0);    % 2/4/2009: Leaving coherence at what it was originally intended to be,    % to see if it has any effect on RT or accuracy:%     rSet('dXdots',dotsIdx,'coherence',coher);    % 2/9/2009: Setting it back to 0, because I think it may very well    % cause ramping of integrators in a way that 0 coherence will not.%     rSet('dXtarget',targetIdx,'penWidth',1,'diameter',0.5);    arrow_flag = 1;else%     rSet('dXtarget',targetIdx,'penWidth',24,'diameter',0.3);    rSet('dXdots',dotsIdx,'coherence',coher);    arrow_flag = 0;end% rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);% PostCoherenceTime = GetSecs;% 10/28/07: Just set PI to 0.5:PI = 0.5;score = 0;% Need an initial delay before first trial:% 10/27/08: Now making a gamma-distributed RSI, with shape and mean% parameters sent by the calling function: scale = D/shape;RSI = gamrnd(shape,scale);rGraphicsBlank;% rSet('dXtarget',blackTargetIdx,'visible',true);if strcmp(cue_type,'a')==1    rSet('dXtarget',targetIdx,'visible',false);    rSet('dXpolygon',triangleIdx,'visible',true);else    rSet('dXpolygon',triangleIdx,'visible',false);    rSet('dXtarget',targetIdx,'visible',true);endrSet('dXtarget',blackTargetIdx,'visible',true);rGraphicsDraw;WaitSecs(RSI);% In order to help randomly select RTs from arrows and dots trials in a% loaded file of RTs (if such a file is supplied by the user), compute% lengths of relevant RT arrays now, rather than inside the while loop% below. if arrow_flag    fast_low_dots_length = length(RT_struct.fast_low_dots_RT);    fast_high_dots_length = length(RT_struct.fast_high_dots_RT);    slow_low_dots_length = length(RT_struct.slow_low_dots_RT);    slow_high_dots_length = length(RT_struct.slow_high_dots_RT);    fast_arrow_length = length(RT_struct.fast_arrow_RT);    slow_arrow_length = length(RT_struct.slow_arrow_RT);end% MAIN TRIAL-CALLING LOOP:while GetSecs - timeSt < blockdur% for i = 1 : length(timing_row)   ntrial = ntrial + 1;      if biasdir < 0.5	   ST_bool = (rand(1) < PI);   else	   ST_bool = (rand(1) > PI );   end   if arrow_flag       if ~isempty(RT_struct)           dot_duration = gamrnd(5,0.5/5);       else           if D == RSI_poss(1)               if coher == coherence_array(1)                   % Randomly select a dot duration during arrow trials                   dots_idx = ceil(rand(1)*fast_low_dots_length);                   arrow_idx = ceil(rand(1)*fast_arrow_length);                   dot_duration = RT_struct.fast_low_dots_RT(dots_idx) - RT_struct.fast_arrow_RT(arrow_idx);               elseif coher == coherence_array(2)                   dots_idx = ceil(rand(1)*fast_high_dots_length);                   arrow_idx = ceil(rand(1)*fast_arrow_length);                   dot_duration = RT_struct.fast_high_dots_RT(dots_idx) - RT_struct.fast_arrow_RT(arrow_idx);               end           elseif D == RSI_poss(2)               if coher == coherence_array(1)                   dots_idx = ceil(rand(1)*slow_low_dots_length);                   arrow_idx = ceil(rand(1)*slow_arrow_length);                   % Randomly select a dot duration during arrow trials                   dot_duration = RT_struct.slow_low_dots_RT(dots_idx) - RT_struct.slow_arrow_RT(arrow_idx);               elseif coher == coherence_array(2)                   dots_idx = ceil(rand(1)*slow_low_dots_length);                   arrow_idx = ceil(rand(1)*slow_arrow_length);                   dot_duration = RT_struct.slow_high_dots_RT(dots_idx) - RT_struct.slow_arrow_RT(arrow_idx);               end           end       end   else       dot_duration = inf;   end   if ST_bool       [RT(ntrial), ER(ntrial), RDir(ntrial), score, premie_t{ntrial},premie_d{ntrial},...           ST_time(ntrial), dot_onset(ntrial), dot_duration(ntrial), dot_offset(ntrial), irrelDirNumerical ] = ...           trial_arrow (dotsIdx, targetIdx, triangleIdx, blackTargetIdx, textIdx_Score, ppd_, 0, rkey, lkey, rkey, D, shape, score, ntrial, money, salary, ...           wdwPtr, cue_type, pahandle_correct, pahandle_antic, daq, contrast_factor, Behavioral, dot_duration);       ST(ntrial) = 'R';   else       [RT(ntrial), ER(ntrial), RDir(ntrial), score, premie_t{ntrial},premie_d{ntrial},...           ST_time(ntrial), dot_onset(ntrial), dot_duration(ntrial), dot_offset(ntrial), irrelDirNumerical ] = ...           trial_arrow (dotsIdx, targetIdx, triangleIdx, blackTargetIdx, textIdx_Score, ppd_, 180, lkey, lkey, rkey, D, shape, score, ntrial, money, salary, ...           wdwPtr, cue_type, pahandle_correct, pahandle_antic, daq, contrast_factor, Behavioral, dot_duration);       ST(ntrial) = 'L';   end         % Keep track of direction of irrelevant motion on arrow trials   % (equals actual motion direction on motion trials):   if irrelDirNumerical == 0       irrelDir(ntrial) = 'R';   else       irrelDir(ntrial) = 'L';   end      %    % Break out of loop if the last trial would've extended the block%    % duration past its limit:%    if terminate_flag%        break%    end  end