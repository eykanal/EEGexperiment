function money = experiment_eeg (subject,Behavioral,lowCoh,highCoh,RTfile)% function money = experiment_eeg (subject,Behavioral,lowCoh,highCoh,RTfile)%% The low and high coherence inputs are only required for EEG% sessions--in behavioral sessions the low and high coherence will% be determined from the psychometric session.%% Each trial consists of the onset of a moving dots stimulus, followed by% freezing. There will always be a fixation point in the middle. As soon as% the dots stop moving, the participant is supposed to press a right or% left button indicating whether right or left motion was observed. If they% are correct, the fixation circle turns Green; if they are incorrect, it% turns Red.%% After every miniblock, the total score (number correct) is displayed in% the center of the screen.%%#################################%####                         ####%#### INITIALIZATION ROUTINES ####%####                         ####%#################################% Default to fMRI settings if no behavioral flag set in the input params:if nargin < 2    Behavioral = 0;end% Before doing anything, let the user confirm that this subject number is% the right one:fprintf( 1, '\n The following information relating to subject %d currently exists: \n\n', subject );% Read in all the files related to subject:d = dir;indices = strmatch( sprintf( 'subject%d_', subject ), { d(:).name } );if isempty( indices )    fprintf( 1, 'New subject: no files related to subject %d in the directory. \n\n', subject );else    for i = 1 : length(indices)        fprintf( 1, '%s\t\t%s\n', d(indices(i)).name, d(indices(i)).date );    endenduser_comment = input('\nDo you want to enter a comment on this run? Answer will be saved as a string. Press return if no comment desired.\n','s');continue_response = input( '\nContinue? Type ''y'' if yes, ''n'' if no.\n', 's' );if strcmp( continue_response, 'y' ) ~= 1    returnend% increment the filename number based on what previous files are thereSessionsCompleted = 0;filename = 'foo';% check for both regular sessions (that won't have the "_\d" appended) and% MEG sessionswhile SessionsCompleted < 1 || exist(strcat(filename, '.mat'),'file') || exist(strcat(filename, '_1.mat'),'file')    SessionsCompleted = SessionsCompleted + 1;    filename = sprintf ('subject%d_ses%d', subject, SessionsCompleted);endfilename = strcat( filename, '.mat' );if ~Behavioral    % flag to skip coherence setting routine    doQuest = 0;       % if not behavioral, experiment must be called with coherence values    if ~exist('lowCoh','var') || ~exist('highCoh','var')        fprintf('please call this experiment with a low and high coherence\n');        return    end        numRuns = 4;    % number of runs; if want more, need to increase the size                    % of the RSI, Shapes, Cohs, and Cues arrays below    blockdur = 120; % 2-minute blocks (for fMRI/EEG)	waitdur = 30;   % 30 second blank period% if behavioral, check if coherences provided... if not, set to defaultselse    % flag to execute coherence setting routine    doQuest = 1;     if ~exist('lowCoh','var') || isempty(lowCoh)        lowCoh = 10;    end    if ~exist('highCoh','var') || isempty(highCoh)        highCoh = 20;    end        numRuns = 1;    % number of runs	blockdur = 240; % duration of a single block in seconds (4 min for Behavioral)	waitdur = 30;   % Should not be relevant for Behavioral sessionsend% load number of sessions completedfid = fopen( sprintf('subject%d_order.mat', subject) );if fid == -1    subj_order_file = sprintf( 'subject%d_order', subject );    SessionsCompleted = 0;else    fclose( fid );    subj_order_file = sprintf( 'subject%d_order', subject );    load( subj_order_file );end% In this experiment, we're covarying (1) two RSI levels, (2) two motion% coherence levels, and (3) two trial types (1: normal dot-motion% discrimination; 2: cued-response with a salient arrow cue, dot-motion is% irrelevant)RSI_poss   = [ 2 2  ];  % Mean RSI ("poss" means possibility)Shape_poss = [ 5 10 ];  % Gamma pdf shape parameter for individual RSI                        % (scale = mean/shape)coherence_array = [lowCoh highCoh];  % Coherence levels: 3 should be hard,                                     % 8 should be easierif exist('RTfile','var') % Check to make sure there IS an RTfile    load(RTfile);    % RTfile contains:    % RT_t     D_t  CueType_t   TrialCoh_t    % BE CAREFUL! If the saved variables have the same name as the ones    % in this script (i.e., the ones changing during the experiment),    % everything will get screwed up. As such, the RT file should store    % variables with different names, which can be done by a    % post-processing step after the original data is collected. This will    % require RTs for every one of the 4 dots conditions, and every one of    % the 4 arrow conditions (really 2, since coherence is 0 in those    % blocks). We'll want one RT for each block, along with an identifier    % of RSI, coherence, and cue-type. Well, if desired, we can just do the    % extraction of these subtypes from the RTfile.    % OK, adding a "_t" to the end of all relevant variables.    RT_struct.fast_arrow_RT = RT_t(find(D_t==RSI_poss(1) & CueType_t=='a'));    if ~isempty(find(D_t==RSI_poss(2)))        RT_struct.slow_arrow_RT = RT_t(find(D_t==RSI_poss(2) & CueType_t=='a'));    else        RT_struct.slow_arrow_RT = RT_struct.fast_arrow_RT;     end        % This collapses over coherence during arrow trials, which is likely to    % be 0, although it was not for some of my own behavioral    % sessions.        % I have set the low coherence to 0 and the high coherence to 1    RT_struct.fast_low_dots_RT  = RT_t(find(D_t==RSI_poss(1) & CueType_t=='d' & TrialCoh_t==0));    RT_struct.fast_high_dots_RT = RT_t(find(D_t==RSI_poss(1) & CueType_t=='d' & TrialCoh_t==1));    RT_struct.slow_low_dots_RT  = RT_t(find(D_t==RSI_poss(2) & CueType_t=='d' & TrialCoh_t==0));    RT_struct.slow_high_dots_RT = RT_t(find(D_t==RSI_poss(2) & CueType_t=='d' & TrialCoh_t==1));else    % Make fake data using a gamma distribution with mean decision time    % = 800 msec, and mean signal detection time = 300 msec:    RT_struct.fast_arrow_RT = normrnd(0.35,0.05*ones(1,1000));    RT_struct.slow_arrow_RT = normrnd(0.35,0.05*ones(1,1000));    % This collapses over coherence during arrow trials, which is likely to    % be 0, although it was not for some of my own behavioral sessions.    RT_shape = 5;    RT_scale = 0.8/5;    RT_struct.fast_low_dots_RT  = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.fast_high_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.slow_low_dots_RT  = gamrnd(RT_shape,RT_scale*ones(1,1000));    RT_struct.slow_high_dots_RT = gamrnd(RT_shape,RT_scale*ones(1,1000));end% money earned by subjects for correct decision [in cents]salary      = 1;    money_psych = 0;% Response keys:keys = [ KbName('Z'), KbName('M') ];lkey = keys(1);rkey = keys(2);global daq;% Initialize the USB device:devices = PsychHID('Devices');daq = DaqDeviceIndex;% If you want to run this without the USB device, set daq to -1:if Behavioral  daq = -1;endif daq > 0    % fix for macbook bug    if length(daq) > 1        daq = 4;    end    errA = DaqDConfigPort(daq, 0, 0);   % Port A will send data out    errB = DaqDConfigPort(daq, 1, 1);   % Port B will receive dataendScreen('Preference','SkipSyncTests',0);rInit({'screenMode','local','showWarnings',true});% Identify computer based on display type[s,w] = unix('system_profiler SPDisplaysDataType');% First look for Mac Pro, then projector, then color LCD. Do in this order % because projector and LCD will probably both be present when projector% plugged in.if strfind(w, 'B223W')  % mac pro    monitorWidth    = 47.5;    viewingDistance = 63.5;elseif strfind(w, 'LE1901w')  % MEG recording room        monitorWidth    = 93;    viewingDistance = 118;elseif strfind(w, 'Color LCD')  % laptop w/o external        monitorWidth    = 28.5;    viewingDistance = 60;   else    monitorWidth    = rGet('dXscreen', 'monitorWidth');    viewingDistance = rGet('dXscreen', 'viewingDistance');    end    rSet('dXscreen', 1, 'monitorWidth',    monitorWidth);rSet('dXscreen', 1, 'viewingDistance', viewingDistance);% 7/19/08: need access to the window pointer for freeze-framing dots.wdwPtr = rWinPtr;% 7/17/07: A bunch of PTB sound manipulation code needs to be initialized:% Perform basic initialization of the sound driver:InitializePsychSound;% Read WAV file from filesystem:expdir = fileparts(which('experiment_eeg.m'));[y, freq, nbits] = wavread(fullfile(expdir,'SOUND16'));wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.% Open the default audio device [], with default mode [] (==Only playback),% and a required latency class of zero 0 == no low-latency mode, as well as% a frequency of freq and nrchannels sound channels.% This returns a handle to the audio device:pahandle_correct = PsychPortAudio('Open', [], [], 0, freq, nrchannels);% Fill the audio playback buffer with the audio data 'wavedata':PsychPortAudio('FillBuffer', pahandle_correct, wavedata);% Now open a channel for the anticipatory error sound:[y, freq, nbits] = wavread(fullfile(expdir,'errorsound'));wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.pahandle_antic = PsychPortAudio('Open', [], [], 0, freq, nrchannels);PsychPortAudio('FillBuffer', pahandle_antic, wavedata);% Also initialize the KbCheck routine:KbCheckMulti;                   % Initialize keyboard check routinetriggercode = KbName('LEFTSHIFT');  % Nope, LEFTSHIFT instead of !RT = [];bl = 1;score = 0;ppd_ = rGet('dXscreen', 1, 'pixelsPerDegree');% Dots features from motion_localizer_translational.m:contrast_factor = 1;        % The percentage of 256 for color saturation (0.1 used in fixed-viewing version)blank_time = 1000;          % 1000 msec blank time at the endpix_degree_size = 0.15;  % This sets pixels to .15 degrees visual angle for a given screenaperture_diam = 10;      % Degrees covered by aperturetarget_diam = 0.3;       % Degrees covered by targetblack_annulus_diam = 2;  % A black target behind the visible target for preventing dot-tracking at fixationdensity = 20;               % dots/degree^2 Downing-Movshon says dots/degree^2/sec -- I don't get why sec is relevantspeed = 7;                  % Dot-speed in deg/secloops = 3;                  % A low-level drawing feature of DotsX codemotion_dur = 500;           % Motion stimulus duration in msec (fixed viewing time)pixelsize = floor(pix_degree_size * ppd_);% The black target imitates the annulus idea in the Kastner lab motion% localizer code, presumably to prevent tracking of individual dots that% move through the fixation point.blackTargetIdx  = rAdd( ...    'dXtarget', 1, ...    'color',    contrast_factor*[0 0 0], ...    'penWidth', 24, ...    'diameter', black_annulus_diam, ...    'visible',  false);% add some dots and a targettargetIdx       = rAdd( ...    'dXtarget', 1, ...    'color',    contrast_factor*[255 255 255], ...    'penWidth', 24, ...    'diameter', target_diam, ...    'visible',  false);dotsIdx         = rAdd( ...    'dXdots',   1, ...    'color',    contrast_factor*[255 255 255], ...    'direction',0, ...    'coherence',coherence_array(1), ...    'diameter', aperture_diam, ...    'size',     pixelsize, ...    'loops',    loops, ...    'density',  density, ...    'speed',    speed, ...    'lifetimeMode', 'random', ...    'visible',  false);triangleIdx     = rAdd( ...    'dXpolygon',1, ...    'visible',  false, ...    'color',    contrast_factor*[255 255 255], ...    'pointList',0.65*target_diam*[-1 1; 1 1; 0 -1]);font_degrees  = 0.7;str           = sprintf('Score: %d', score);textwidth     = font_degrees*length(str);x_pos         = -0.3*textwidth;textIdx_Score = rAdd( ...    'dXtext',   1, ...    'visible',  false, ...    'x',        x_pos,  ...    'y',        0,  ...    'size',     floor(font_degrees*ppd_),  ...    'font',     'Courier',  ...    'color',    contrast_factor*[1 1 1]*255,  ...    'string',   str);%############################%####                    ####%#### BEHAVIORAL ROUTINE ####%####                    ####%############################% if behavioral...if doQuest    str = {};    str{1} = 'In every trial, you will see dots moving ';    str{2} = 'on the screen. Most will jump randomly,';    str{3} = 'but some will move to the left or to the';    str{4} = 'right. You will earn a point by pressing';    str{5} = 'Z for leftward dot-motion, and M for';    str{6} = 'rightward dot-motion. ';    str{7} = '';    str{8} = '(Press the ''Space'' key to continue.)';    showText(str);        str = {};    str{1} = 'You''ll hear a tone when you score a point.';    str{2} = 'Your current score will be shown every 5 trials.';    str{3} = '';    str{4} = '(Press the ''Space'' key to continue.)';    showText(str);        str = {};    str{1} = 'Please try to keep your head the same';    str{2} = 'distance from the screen at all times, with';    str{3} = 'your gaze centered on the middle of the screen.';    str{4} = '';    str{5} = '(Press the ''Space'' key to continue.)';    showText(str);        str = {};    str{1} = 'Try not to press any keys before the fixation';    str{2} = 'dot changes from white to blue -- this will';    str{3} = 'delay the dots from appearing, and you will';    str{4} = 'hear a buzzing sound.';    str{5} = '';    str{6} = 'To begin the task, press the ''Space'' key.';    showText(str);        % do a quest block to establish the correct coherence    tmp_coherence = 5;  % coherence is irrelevant because it will be varied in                         %   the quest blocks--left in for consistency    RSIconst = 1;       % response-stimulus interval (fixed for quest blocks)    PIconst = 0.5;      % bias is fixed to 0.5 (no bias)    NpsychTrials = 80;  % 80 psych trials take about 17 minutes    if SessionsCompleted==0        coherVec = [2.5 5 8 12.5 25];    else        coherVec = [1.5 2.5 5 8 12.5];    end        % use a psychometric block instead of a quest block    [STpsych, ST_timePsych, RTpsych, ERpsych, RDirPsych, PiDirPsych, ...        SubScore, score, premie_t, premie_e, coherenceVec, lowCoh, ...        highCoh] = ...     psychometric_block ...        ( RSIconst, Shape_poss(1), coherVec, ...        NpsychTrials, dotsIdx, targetIdx, blackTargetIdx, ...        textIdx_Score, lkey, rkey, PIconst, 1, salary, wdwPtr, ...        pahandle_correct, pahandle_antic, daq);    save (filename, 'blank_time', 'pix_degree_size', 'aperture_diam', ...        'pixelsize', 'target_diam', 'black_annulus_diam', 'ppd_', ...        'density', 'speed', 'loops', 'waitdur', 'blockdur', 'lowCoh', ...        'highCoh', 'STpsych', 'ST_timePsych', 'RTpsych', 'ERpsych', ...        'RDirPsych','PiDirPsych','coherenceVec','RSI_poss','Shape_poss');        % correct for the possibility that the estimation algorithm is totally     %   off the wall    if (lowCoh>8) || (lowCoh<0)        lowCoh=8;    end    if (highCoh>15) || (highCoh<0)        highCoh = 15;    endendcoherence_array = [ lowCoh highCoh ];    % Leigh didn't like my previous scheme, since it can fall prey to agressive% high-pass filtering (with a really high lower-frequency cutoff). So we% now pick two variations on an RSI ordering, two variations on a coherence% ordering, and two variations on a cue-type ordering. Then we are free to% mix together one ordering of each, for 8 unique condition orderings. % RSI order: A B B A B A A B; or B A A B A B B A% Coherence order: C D C D D C D C; or D C D C C D C D % Cue order: E F F E E F F E; or F E E F F E E FRSIs = [ RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2); ...         RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) ];Shapes = [ Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2); ...           Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) ];Cohs = [ coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1); ...         coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) ];% 'd': dots; 'a': arrow% EK (10/26/10) - removed all arrow ('a') trialsCues = [ 'd' 'd' 'd' 'd' 'd' 'd' 'd' 'd'; ...         'd' 'd' 'd' 'd' 'd' 'd' 'd' 'd' ];    % Using Rafal's names for trial-indexing of the returned data:% 'ib' refers to 'index beginning' % 'ie' refers to 'index end'% 'bl' is the block number%######################%####              ####%#### MAIN ROUTINE ####%####              ####%######################str = {};str{1} = 'Now your task is to gain as many points';str{2} = 'as possible. The experiment has a fixed';str{3} = 'duration, so the faster you go, the more';str{4} = 'money you can make. It''s OK to be greedy!';str{5} = '';str{6} = '(Press the ''Space'' key to continue.)  ';    showText(str);str = {};str{1} = 'Your task is to indicate the direction of the';str{2} = 'motion or arrows (depending on the block) with';str{3} = 'Z for left ';str{4} = 'M for right';str{5} = '';str{6} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str{1} = 'When you score a point, you''ll hear a';str{2} = 'sound, and the circle or triangle will';str{3} = 'turn green. For an error it will turn';str{4} = 'red. You''ll see your current score every';str{5} = '5 trials.';str{6} = '';str{7} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str{1} = 'Do whatever necessary to make as much money';str{2} = 'as possible.';str{3} = 'Z = left ';str{4} = 'M = right';str{5} = '';str{6} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str = {'Press ''Space'' to start,','then fixate on the central circle'};showText(str);if ~exist('runsDone','var')	runsDone = 0;end% the main experimental loopfor runNo = (runsDone +1):numRuns    % set the filename for the saved .mat file for this run    filename = regexprep( filename, 'ses(\d+)(_\d+)?.mat', strcat( 'ses$1_', num2str(runNo), '.mat'));    % get rid of data from last run    clear ( 'arrow_direction', ...		'arrow_dur', ...		'arrow_offset', ...		'arrow_onset', ...		'blocknum', ...		'cohVec', ...		'cueVec', ...		'D', ...		'ER', ...		'PI', ...		'PiDir', ...		'Premie_d', ...		'Premie_t', ...		'RDir', ...		'RT', ...		'shapeVec', ...		'ST_time', ...		'ST', ...		'trialnum' );        RT = [];    money = 0;    if runNo > 1        % Tell subject to wait while we reset the scanner        str = {'Saving MEG data, please wait...'};        showText(str);    end    % introduce the run    str = sprintf('RUN: %d / %d', runNo, numRuns );    showText(str);    % Decide on the random order of the conditions    % Now just pick a value of 1 or 2 for each of these features:    RSI_row = floor(rand(1)+1.5);    Coh_row = floor(rand(1)+1.5);    Cue_row = floor(rand(1)+1.5);    % The next lines isolate one row from the above data structures. These    % can be indexed by the block-number in the main experiment loop below.    RSI         = RSIs(RSI_row,:);    Shape       = Shapes(RSI_row,:);    coherence   = Cohs(Coh_row,:);    cue_type    = Cues(Cue_row,:);    numblocks   = length(RSI);        if runNo == numRuns        addBlock = 2;    else        addBlock=0;    end    % execute each block    for bl = 1 : numblocks        %% some formatting        if cue_type(bl) == 'a'            this_block_type = '**';        else            this_block_type = coherence(bl);        end                fprintf(1, 'This block (%d/%d): ''%s-%02d''', bl, numblocks, cue_type(bl), this_block_type);                resting_arrow(numblocks - bl + 1 + addBlock, money, cue_type(bl) );                [STbl, irrelDirbl, ST_timebl, arrow_onsetbl, arrow_durbl, ...            arrow_offsetbl,RTbl, ERbl, RDirbl, PiDirbl, score, ...            premie_t,premie_d,arrow_direction] = ...        block ( ...            RSI(bl), RSI_poss,Shape(bl), coherence(bl), ...            coherence_array, cue_type(bl), blockdur, dotsIdx, targetIdx,...            triangleIdx, blackTargetIdx, textIdx_Score, ppd_, lkey,rkey,...            money, salary,wdwPtr, pahandle_correct, pahandle_antic, daq,...            contrast_factor, RT_struct);                ib                  = length(RT) + 1; %index of the begining of inserted block        ie                  = length(RT) + length(RTbl);	%index of the end of inserted block                ST(ib:ie)           = STbl;        irrelDir(ib:ie)     = irrelDirbl;   % Direction of irrelevant motion on arrow trials (will equal ST on motion trials)        ST_time(ib:ie)      = ST_timebl;        arrow_onset(ib:ie)  = arrow_onsetbl;        arrow_direction(ib:ie) = arrow_direction;        arrow_dur(ib:ie)    = arrow_durbl;        arrow_offset(ib:ie) = arrow_offsetbl;	        shapeVec(ib:ie)     = Shape(bl);        cohVec(ib:ie)       = coherence(bl);        cueVec(ib:ie)       = cue_type(bl);        RT(ib:ie)           = RTbl;        ER(ib:ie)           = ERbl;        RDir(ib:ie)         = RDirbl;        blocknum(ib:ie)     = bl + numblocks*(runNo-1);        trialnum(ib:ie)     = 1:length(RTbl);        D(ib:ie)            = RSI(bl);        PI(ib:ie)           = 0.5;        PiDir(ib:ie)        = PiDirbl; % For 50:50 stimuli, this variable is meaningless        Premie_t(ib:ie)     = premie_t;        Premie_d(ib:ie)     = premie_d;	        money = money + score * salary;                % display average performance for this block, for all blocks up to        % now        cur_perform = 100 * (1 - (sum(ERbl)/length(ERbl)));        cum_perform = 100 * (1 - (sum(ER(cueVec == cue_type(bl) & cohVec == coherence(bl)))/length(ER(cueVec == cue_type(bl) & cohVec == coherence(bl)))));        fprintf(1, ', Current performance: %3.0f%%, Cumulative performance: %3.0f%%\n', cur_perform, cum_perform);	         if bl==numblocks            runsDone = runsDone + 1;        end                % save the data        if doQuest            save (filename, 'runsDone', 'ST', 'ST_time','RT', 'ER', ...                'RDir', 'blocknum', 'trialnum','D', 'PI','cohVec', ...                'cueVec','shapeVec','PiDir', 'money','Premie_t', ...                'Premie_d', 'contrast_factor','blank_time', ...                'pix_degree_size', 'aperture_diam','pixelsize', ...                'target_diam','black_annulus_diam','ppd_','density', ...                'speed','loops', 'waitdur','blockdur','numblocks', ...                'STpsych','ST_timePsych','RTpsych','ERpsych', ...                'RDirPsych','PiDirPsych','coherence_array', ...                'arrow_onset','arrow_dur','arrow_offset','RSI_poss', ...                'Shape_poss','coherenceVec');             else            save (filename, 'runsDone', 'ST', 'ST_time','RT', 'ER', ...                'RDir', 'blocknum', 'trialnum','D', 'PI','cohVec', ...                'cueVec','shapeVec', 'PiDir', 'money','Premie_t', ...                'Premie_d', 'contrast_factor', 'blank_time', ...                'pix_degree_size', 'aperture_diam','pixelsize', ...                'target_diam','black_annulus_diam','ppd_','density', ...                'speed','loops', 'waitdur','blockdur','numblocks', ...                'coherence_array','arrow_onset','arrow_dur', ...                'arrow_offset','RSI_poss','Shape_poss','arrow_direction');            end    endendresting (2, money);%#####################################%####                             ####%#### SIGNAL DETECT SPEED ROUTINE ####%####                             ####%#####################################% Now add in two blocks that test signal detection speed, each of 2.5 minutes% (leading to a total experiment time of 90 minutes):str = {};str{1} = 'OK, just two shorter blocks left.';str{2} = '';str{3} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str{1} = 'These two blocks will each last 2 minutes.';str{2} = 'In these blocks, simply press the specified';str{3} = 'key as soon as you see any dots at all.';showText(str);str{1} = 'In the first block, always press the Z key';str{2} = 'with your left index finger.';str{3} = 'In the second block, always press the M key';str{4} = 'with your right index finger.';str{5} = '';str{6} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str{1} = sprintf('You will be paid %d cent for each point.', salary);str{2} = 'Try to earn as much as you can.';str{3} = '';str{4} = '(Press the ''Space'' key to continue.)';showText(str);str = {};str{1} = 'Please rest now.';str{2} = 'In this block, always press the Z key.';str{3} = 'Whenever you are ready to';str{4} = 'continue, press SPACE.';str{5} = 'Number of blocks remaining: 2';str{6} = sprintf('Total earned: $%.2f', money/100);showText(str);SDdur = 120;[Left_ST, Left_ST_time, Left_RT, Left_ER, score1, Left_premie_t, ...    Left_premie_d] = ...sig_det_block( ...    RSI_poss(1), Shape_poss(1), coherence_array(1), SDdur, 'Left', ...    dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, ...    rkey, money, salary,pahandle_correct, pahandle_antic, daq, ...    contrast_factor); money = money + score1 * salary;str = {};str{1} = 'Please rest now.';str{2} = 'In this block, always press the M key.';str{3} = 'Whenever you are ready to';str{4} = 'continue, press SPACE.';str{5} = 'Number of blocks remaining: 1';str{6} = sprintf('Total earned: $%.2f', money/100);showText(str);[Right_ST, Right_ST_time, Right_RT, Right_ER, score2, Right_premie_t, ...    Right_premie_d] = ...sig_det_block( ...    RSI_poss(1), Shape_poss(1), coherence_array(1), SDdur, 'Right', ...    dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, ...    rkey, money, salary,pahandle_correct, pahandle_antic, daq, ...    contrast_factor);money = money + score2 * salary + money_psych*salary;runsDone = 0;%Finishing the experimentif doQuest    save (filename,'runsDone', 'ST', 'ST_time', 'RT', 'ER', 'RDir', ...        'blocknum', 'trialnum', 'D', 'PI', 'PiDir', 'money', 'Left_ST', ...        'Left_ST_time', 'Left_RT', 'Left_ER', 'Left_premie_t', 'cohVec', ...        'cueVec','shapeVec','Left_premie_d', 'Right_ST', 'Right_ST_time', ...        'Right_RT', 'Right_ER', 'Right_premie_t', 'Right_premie_d', ...        'Premie_t', 'Premie_d', 'contrast_factor','blank_time', ...        'pix_degree_size', 'aperture_diam','pixelsize', 'target_diam', ...        'black_annulus_diam','ppd_','density','speed','loops', 'waitdur', ...        'blockdur','numblocks','coherence_array','arrow_onset','arrow_dur', ...        'arrow_offset','RSI_poss','Shape_poss','coherenceVec','STpsych', ...        'ST_timePsych','RTpsych','ERpsych','RDirPsych','PiDirPsych');  else    save (filename,'runsDone', 'ST', 'ST_time', 'RT', 'ER', 'RDir', ...        'blocknum', 'trialnum', 'D', 'PI', 'PiDir', 'money', 'Left_ST', ...        'Left_ST_time', 'Left_RT', 'Left_ER', 'Left_premie_t', 'cohVec', ...        'cueVec','shapeVec','Left_premie_d', 'Right_ST', 'Right_ST_time', ...        'Right_RT', 'Right_ER', 'Right_premie_t', 'Right_premie_d', ...        'Premie_t', 'Premie_d', 'contrast_factor','blank_time', ...        'pix_degree_size', 'aperture_diam','pixelsize', 'target_diam', ...        'black_annulus_diam','ppd_','density','speed','loops', 'waitdur', ...        'blockdur','numblocks','coherence_array','arrow_onset', 'arrow_dur',...        'arrow_offset','RSI_poss','Shape_poss','arrow_direction');  end% thankyou (money)% opponent_money = thankyou (money, opponent_money, score1+score2, salary, windowptr);% money = 0; opponent_money = 0; salary = 0;rSet('dXdots',dotsIdx,'visible',false);rSet('dXtarget',targetIdx,'visible',false);rSet('dXtarget',blackTargetIdx,'visible',false);rGraphicsDraw;thankyou (money, score1+score2);% Now update the subject order file. By doing this at the end of the% experiment, interrupted sessions are totally ignored, both from the% perspective of the individual subject's order file and for the master% order file that enables counterbalancing of conditions across subjects% and sessions. This means that starting an interrupted session over% again will repeat the block ordering for the subject. Assuming that% interruptions typically happen early in the session because the% experimenter realized he/she made a mistake, this is not too problematic.% But if a power failure happens near the end of a session, they will get% exactly the same ordering the next time they do the session -- but in% that case, the subject will almost certainly want to come back on% another day and will hopefully forget the ordering, so this seems the% best solution for the problem of interruptions.SessionsCompleted = SessionsCompleted + 1;% save( subj_order_file, 'PI_vals', 'D_vals', 'SessionsCompleted' );% save( subj_order_file, 'PermutationList', 'SessionsCompleted' );save( subj_order_file, 'SessionsCompleted' );rDone;% Close the audio device:PsychPortAudio('Close', pahandle_correct);PsychPortAudio('Close', pahandle_antic);return% catch%     Screen('CloseAll');%     %     psychrethrow(psychlasterror);%     rethrow(lasterror);%     PsychPortAudio('Close', pahandle_correct);%     PsychPortAudio('Close', pahandle_antic);%     FlushEvents;% end