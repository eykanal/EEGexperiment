function [RT, ER, RDir, score] = sig_det_block (coher, blockdur, lkey, rkey, respdir)% function [ST,RT,score] = sig_det_block(coher,blockdur,lkey,rkey);% respdir is the direction, 'Left' or 'Right', of the responses listened % to by the computer (so that lefthand and righthand RTs can be gathered % separately).% % This function is a simplified version of block.m which just checks for % speeded reaction time. It gives a point for any legal response.% Here, D is always 0.5 seconds.%% function [ST, RT, ER, score] = block (coher, blockdur, lkey, rkey, D, PI)%% Block of experiment% Inputs:%  coher - coherence of dots%  blockdur - duration of the block in seconds%  lkey - correct key for dots moving left%  rkey - correct key for dots moving right%  D - Response Stimulus Interval% %  Dpen - Additional Delay after making an error% Outputs: vectors as long as number of trials%  ST - sequnece of stimuli: 0 - small number of stars, 1 - high number of stars%  RT - reaction times [in seconds]%  ER - errors during trials: error = 1, correct = 0%  score - amount of points earned at the end of the trial% PI -- bias in favored direction% 2/19/04: RDir is a new variable that records the actual leftward and rightward % responses for each trial.rInit ('visible', 1);	%initializes screen and makes it visiblewindowptr = screen('Windows');screen (windowptr, 'TextFont', 'Courier New');wartime = 5;		%how long should be the warning before the trial[rect] = screen (windowptr, 'Rect');SetMouse (rect(3), rect(4));for i = wartime:-1:1	screen (windowptr, 'TextSize', 48);	TextCenter (windowptr, 'Get Ready', -100, 12);	TextCenter (windowptr, sprintf ('Block starts in %ds', i), 0, 12);	screen (windowptr, 'TextSize', 20);	TextCenter (windowptr, sprintf ('Remember: "%c" - left; "%c" - right', lkey, rkey), 200, 12);	WaitSecs(0.1);	screen (windowptr, 'FillRect', 255);endtimeSt = GetSecs;ntrial = 0;score = 0;rAdd ('dots', [1], 'coherence', coher, 'diameter', 56);	% Creates an objects of dots% % 2/19/04: Adding a randomization of the direction favored by bias, so that it % % isn't always toward the right:% biasdir = rand(1);% if biasdir < 0.5% 	PiDirbl = 'R';% else% 	PiDirbl = 'L';% endD = 0.5;  % Set D to a constant 0.5 (which gets varied slightly in sig_det_trial)% 5/2/06: Given a particular D value for mean RSI, compute a set of RSI values based on an % exponential density that has mean equal to D, as well as a rest or refractory period of % 400 msec, to let subjects regroup for the next trial. This requires solving for lambda in % the following equation:%% 1/lambda + 0.4 = D   ==>   lambda = 1/(D-0.4)%% Compute the bin boundaries for method 3 on p.76 of Luce, using 25 msec time increments % starting at 400 msec and going up to max possible RSI, by which point 99% of RSIs should % have elapsed: maxRSI = log(.01)/(-lambda):lambda = 1/(D-0.3);maxRSI = log(.01)/(-lambda) + 0.3;% Compute the half-percentiles of the exponential density with these parameters. First % compute a fine mesh approximation to the cumulative distribution of RSI over the % complete range of possible RSIs:F = [];for t = 0 : 0.001 : maxRSI - 0.3	F = [ F, 1 - exp(-lambda*t) ];end% Now look at a mesh of F values, and find which times correspond most closely to the % F-mesh points:t = [ 0 : 0.001 : maxRSI - 0.3 ];bin_bound(1) = 0;for q = 1 : 200	F_nearest_lower = F(find( F < q*(1/200) ));	if isempty(F_nearest_lower)		F_nearest_lower = 0;	end	F_nearest_upper = F(find( F > q*(1/200) ));	if isempty(F_nearest_upper)		F_nearest_upper = F(end);	end	F_nearest_lower = F_nearest_lower(end);	F_nearest_upper = F_nearest_upper(1);	% Now I could do some fancy interpolation here, but I'll keep it simple to limit any 	% need for debugging. Just take the nearest F value to the quantization value q:	if abs(F_nearest_lower - q*(1/200)) <= abs(F_nearest_upper - q*(1/200))		F_nearest = F_nearest_lower;	else		F_nearest = F_nearest_upper;	end% 	keyboard	bin_bound(q+1) = t( find(F == F_nearest) );end% Take midpoints of bins as the quantized RSI values (following Luce):for q = 1 : 200	RSI_vector(q) = 0.5*(bin_bound(q+1)-bin_bound(q));endRSI_vector = RSI_vector + 0.3;while GetSecs - timeSt < blockdur	ntrial = ntrial + 1;		%    if biasdir < 0.5	% 	   ST_bool = (rand(1) < PI);	%    else	% 	   ST_bool = (rand(1) > PI );	%    end		%    if ST_bool	%       [RT(ntrial), ER(ntrial), RDir(ntrial), score] = trial (windowptr, 0, rkey, D, score);	% 	  ST(ntrial) = 'R';	%    else	%       [RT(ntrial), ER(ntrial), RDir(ntrial), score] = trial (windowptr, 180, lkey, D, score);	% 	  ST(ntrial) = 'L';	%    end		% Randomize dot direction:	bool = (rand(1) < 0.5);	if bool		angle = 0;	else 		angle = 180;	end			[RT(ntrial), ER(ntrial), RDir(ntrial), score] = sig_det_trial (windowptr, angle, rkey, RSI_vector, score, respdir);	endFlushEvents (['keydown']); 	%in order to avoid eating the keyrDone;					% turns off the screen and destroys all objects