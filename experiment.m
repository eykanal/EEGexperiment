function money = experiment (subject)% 7/12/08: This is a first-pass attempt at a fixed viewing-time fMRI design% in which five 30 second mini-blocks each of a fixed coherence (one of% five% possible levels), are counterbalanced within roughly 4 minute runs. Each% trial has a fixed viewing time of 500 msec, and each trial is separated% by a jittered ISI of 1, 2 or 3 TRs, with a TR of 2 seconds, and with a% probability for each ISI that best approximates an exponential% distribution with mean equal to 4 seconds. Thus, at roughly five seconds% per trial (ISI+viewing time), we figure we can get about six trials per% miniblock. With five runs, this gives us roughly 30 trials at each% coherence level.%% Each trial consists of the onset of a moving dots stimulus, followed by% freezing. There will always be a fixation point in the middle. As soon as% the dots stop moving, the participant is supposed to press a right or% left button indicating whether right or left motion was observed. If they% are correct, the fixation circle turns Green; if they are incorrect, it% turns Red.%% Between trials, during the ISI period, a static dot pattern is displayed,% so that BOLD responses to the luminance and stuff can be subtracted out.% I'm not entirely sure that's a fully legitimate control condition, but% it's what the Kastner lab used or uses.%% After every miniblock, the total score (number correct) is displayed in% the center of the screen.%% This program spits out the times at which stimulus onsets occur. These% are jittered, so we need a record of the onset times in order to% correctly implement regressors for fMRI analysis. We of course all need a% record of left & right button presses.%%% MAJOR REVISION:%% 9/24/08: This is a first-pass at a free-response -- not fixed-viewing --% fMRI design. It consists of the following:%% 1) 2-minute blocks, approximately. This will allow for adaptation of DDM% parameters based on experience, and we can still throw out the first 5% trials of a block if necessary. 30 sec rest between blocks, and 15% seconds before the first block and after the last block for 10 minute% runs.%% 2) 12 conditions: factorially covarying coherence (3 levels), salient-cue% or not (2 levels), and 2 levels of some other variable, such as RSI, or% level of asymmetry in rewards or prior probabilities for left vs. right% stimuli.%% 3) 4 blocks per scanner-run, counterbalanced%% 4) 6 runs per experimental session, for a total of 60 minutes.%% 5) RSIs will be selected from a pseudo-exponential distribution, and% since we won't know how many trials will fit into a block, we will have% to make a choice about how to end blocks. At each trial, compute the new% RSI, plus 2 sec for a maximal RT. If that's within the time% limit of the block, present the stimulus. If not, then just wait out the% end of the block. Now, if the stimulus is presented but the block% duration times out, and the participant still hasn't responded, just cut% off the stimulus, and don't record a response. Otherwise, we could get% into serious timing difficulties. %% 10/27/08: Leigh was concerned about four-block runs, and we set up% 8-block runs along with the necessary counterbalancing. But that leads to% 20-minute runs, 3 per scan session, and Mike was taken a little bit taken% aback by that. I would like to insert prompts after each 30 second rest% period to allow the subject to control when the next block starts, but I% think Leigh thinks that that will cause possible problems. They can't% talk to us anyway during a run. Nevertheless, just the smallest amount of% interaction would be enough to help me if I was starting to feel trapped.% For now, code up for 8-block/2-minute runs with 30-sec interspersed rest,% and add the participant-control prompt later.% Before doing anything, let the user confirm that this subject number is% the right one:fprintf( 1, '\n The following information relating to subject %d currently exists: \n\n', subject );% Read in all the files related to subject:d = dir;indices = strmatch( sprintf( 'subject%d_', subject ), { d(:).name } );if isempty( indices )    fprintf( 1, 'New subject: no files related to subject %d in the directory. \n\n', subject );else    for i = 1 : length(indices)        fprintf( 1, '%s\t\t%s\n', d(indices(i)).name, d(indices(i)).date );    endendcontinue_response = input( '\nContinue? Type ''y'' if yes, ''n'' if no.\n', 's' );if strcmp( continue_response, 'y' ) ~= 1    return    % 7/18/08: Not allowing this right now -- using a range of fixed    % coherences:    % else    % 	coherence_response = input( '\nDo you want to change the coherence? Type ''y'' or ''n''.\n', 's' );    % 	if strcmp( coherence_response, 'y' ) == 1    % 		coherence = input( '\nEnter a coherence value, from 0 to 256 -- 110 is difficult: \n' );    % 		coherence_flag = 1;    % 	else    % 		%coherence = 110;    % 		coherence_flag = 0;    % 	endend% 11/5/08: Not doing the following stuff anymore . . .% Now a permutation exists in Vector2. For each subject, save the particular% ordering. There should be a unique permutation for each session for each% subject. The odds of generating two identical permutations are extremely% small. For that reason, you can generate the permutations on the fly before% each session. Then you can just save them at the start of each session.fid = fopen( sprintf('subject%d_order.mat', subject) );if fid == -1    subj_order_file = sprintf( 'subject%d_order', subject );    SessionsCompleted = 0;%     % 	PIbl = PI_vals( SessionsCompleted, : );%     % 	Dbl = D_vals( SessionsCompleted, : );%     PIbl = Condition( 1, Permutation );%     Dbl = Condition( 2, Permutation );%     PermutationList = Permutation;else    fclose( fid );    % Order file already exists, so use it%     PIbl = Condition( 1, Permutation );%     Dbl = Condition( 2, Permutation );%     subj_order_file = sprintf( 'subject%d_order', subject );    load( subj_order_file );%     % The above line will load the current SessionsCompleted value and also the%     % current value of a variable named PermutationList.%     PermutationList = [PermutationList; Permutation];% %     if SessionsCompleted >= 10%         fprintf( 1, 'Already completed 10 sessions for subject %d.\n', subject );%         return%     end% % %     % Do this updating to the subject order file at the end of the experiment:%     % 	SessionsCompleted = SessionsCompleted + 1;%     % 	save( subj_order_file );% end% In this experiment, we're covarying two RSI levels, two motion coherence% levels, and two trial types (1: normal dot-motion discrimination; 2:% cued-response with a salient arrow cue, dot-motion is irrelevant)RSI_poss = [ 2 4 ];      % Mean RSI ("poss" means possibility)Shape_poss = [ 5 10 ];   % Gamma pdf shape parameter for individual RSI (scale = mean/shape)coherence_array = [ 3 8 ];  % Coherence levels: 3 should be hard, 8 should be easier% For debugging:RSI_poss = [ 2 3 ];      % Mean RSI ("poss" means possibility)Shape_poss = [ 5 10 ];   % Gamma pdf shape parameter for individual RSI (scale = mean/shape)coherence_array = [ 50 25 ];  % Coherence levels: 3 should be hard, 8 should be easiercoherence_array = [ 6 12 ];% Leigh didn't like my previous scheme, since it can fall prey to agressive% high-pass filtering (with a really high lower-frequency cutoff). So we% now pick two variations on an RSI ordering, two variations on a coherence% ordering, and two variations on a cue-type ordering. Then we are free to% mix together one ordering of each, for 8 unique condition orderings. % RSI order: A B B A B A A B; or B A A B A B B A% Coherence order: C D C D D C D C; or D C D C C D C D % Cue order: E F F E E F F E; or F E E F F E E FRSIs = [ RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2); ...    RSI_poss(2) RSI_poss(1) RSI_poss(1) RSI_poss(2) RSI_poss(1) RSI_poss(2) RSI_poss(2) RSI_poss(1) ];Shapes = [ Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2); ...    Shape_poss(2) Shape_poss(1) Shape_poss(1) Shape_poss(2) Shape_poss(1) Shape_poss(2) Shape_poss(2) Shape_poss(1) ];Cohs = [ coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) ...    coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1); ...    coherence_array(2) coherence_array(1) coherence_array(2) coherence_array(1) ...    coherence_array(1) coherence_array(2) coherence_array(1) coherence_array(2) ];Cues = [ 'd' 'a' 'a' 'd' 'd' 'a' 'a' 'd'; ...    'a' 'd' 'd' 'a' 'a' 'd' 'd' 'a' ];    % 'd': dots; 'a': arrow% For behavioral sessions, just use all dots trials:Cues = ['d','d','d','d','d','d','d','d';     'd','d','d','d','d','d','d','d' ];% Now just pick a value of 1 or 2 for each of these features:RSI_row = floor(rand(1)+1.5);Coh_row = floor(rand(1)+1.5);Cue_row = floor(rand(1)+1.5);% The next lines isolate one row from the above data structures. These can% be indexed by the block-number in the main experiment loop below.RSI = RSIs(RSI_row,:);Shape = Shapes(RSI_row,:);coherence = Cohs(Coh_row,:);cue_type = Cues(Cue_row,:);salary = 1;					%money earned by subjects for correct decision [in cents]% keys = ['Z', 'M'];			%keys used for responses% 7/18/08: Scanner's button box uses numeral keys. 6 and 9 encode pinky and% forefinger buttons on the Left (I think) button box. Or else right. The% other shift-characters are needed too to identify the key: '6^' and '9('.keys = [ KbName('6^'), KbName('9(') ];% 10/27/08: Now using behavioral keys:keys = [ KbName('Z'), KbName('M') ];% blockdur = 240;				%duration of a single block in seconds% bldurpra = 240;				%duration of a practice block% blockdur = 120; % 2-minute blocks% waitdur = 30;   % 30 second blank period% For debugging:blockdur = 10;waitdur = 2;% checking existence of the datafile% filename = sprintf ('subject%d_ses%d.mat', subject, SessionsCompleted);filename = sprintf ('subject%d_ses%d.mat', subject, SessionsCompleted + 1);fid = fopen (filename, 'r');if fid ~= -1    fclose (fid);    data_exists_response = input ('\n\nA datafile for this subj/session already exists. Replace it (y/n)?\n', 's');    if strcmp( data_exists_response, 'n' ) || strcmp( data_exists_response, 'N' )        fprintf(1, '\n\nOK, then please run function experiment with another subject number.\n\n');        return    endend% continue_response = input( '\nContinue? Type ''y'' if yes, ''n'' if no.\n', 's' );lkey = keys(1);rkey = keys(2);rand ('state', sum(100*clock));randn ('state', sum(100*clock));% Initialize the USB device:devices = PsychHID('Devices');daq = DaqDeviceIndex;% % If you want to run this without the USB device, set daq to -1:daq = -1;% Encapsulate everything in a try-catch to get the screen back from PTB:% tryrInit('local'); % 7/16/07 -- shifting to DotsX code% 7/19/08: need access to the window pointer for freeze-framing dots.wdwPtr = rWinPtr;% % Get access to ROOT_STRUCT so it can be saved:% global ROOT_STRUCT;% % ROOT_STRUCT% 7/17/07: A bunch of PTB sound manipulation code needs to be initialized:% Perform basic initialization of the sound driver:InitializePsychSound;% Read WAV file from filesystem:% [y, freq, nbits] = wavread(wavfilename);[y, freq, nbits] = wavread('SOUND16');wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.% Open the default audio device [], with default mode [] (==Only playback),% and a required latencyclass of zero 0 == no low-latency mode, as well as% a frequency of freq and nrchannels sound channels.% This returns a handle to the audio device:pahandle_correct = PsychPortAudio('Open', [], [], 0, freq, nrchannels);% Fill the audio playback buffer with the audio data 'wavedata':PsychPortAudio('FillBuffer', pahandle_correct, wavedata);% Now open a channel for the anticipatory error sound:[y, freq, nbits] = wavread('errorsound');wavedata = y';nrchannels = size(wavedata,1); % Number of rows == number of channels.% Open the default audio device [], with default mode [] (==Only playback),% and a required latencyclass of zero 0 == no low-latency mode, as well as% a frequency of freq and nrchannels sound channels.% This returns a handle to the audio device:pahandle_antic = PsychPortAudio('Open', [], [], 0, freq, nrchannels);% Fill the audio playback buffer with the audio data 'wavedata':PsychPortAudio('FillBuffer', pahandle_antic, wavedata);% Also initialize the KbCheck routine:KbCheckMulti;                   % Initialize keyboard check routinetriggercode = KbName('1!');     % This actually needs to change to '!' for true scanner triggeringtriggercode = KbName('LEFTSHIFT');  % Nope, LEFTSHIFT instead of !RT = [];bl = 1;% welcome5;score = 0;% Print text saying to hit some key to start, and then wait for trigger:% 7/17/07: Get the pixels-per-degree for DotsX:ppd_ = rGet('dXscreen', 1, 'pixelsPerDegree');fontsize = 20;font_degrees = 0.7;str = sprintf ('Press a button to start, then fixate on the central circle');%     textwidth = fontsize*length(str)/ppd_;%     textwidth = font_degrees*length(str)/ppd_;textwidth = font_degrees*length(str);x_pos = -0.3*textwidth;textIdx_Start = rAdd('dXtext', 1, 'visible', true, ...    'x', x_pos, 'y', 0, ...    'size', floor(font_degrees*ppd_), ...    'font', 'Courier',  ...    'color', [1 1 1]*255, ...    'string', str);rGraphicsDrawMulti(inf);rSet('dXtext',textIdx_Start,'visible',false);while KbCheckMulti; endrGraphicsDraw;% % Wait for scanner trigger:% while 1%     %         while KbCheckMulti; end% %     [ keyIsDown, seconds, keyCode ] = KbCheckMulti;    %     [ keyIsDown, seconds, keyCode ] = KbCheck;%     if keyIsDown%         if keyCode(triggercode)%             break%         end%     end%     %         WaitSecs(0.02);% end% Dots features from motion_localizer_translational.m:contrast_factor = 1;   % The percentage of 256 for color saturation (0.1 used in fixed-viewing version)blank_time = 1000;      % 1000 msec blank time at the endpix_degree_size = 0.15;  % This sets pixels to .15 degrees visual angle for a given screenaperture_diam = 25;     % Degrees covered by apertureaperture_diam = 10;target_diam = 0.3;      % Degrees covered by targetblack_annulus_diam = 2;     % A black target behind the visible target for preventing dot-tracking at fixationpixelsize = floor(pix_degree_size * ppd_);density = 20;           % dots/degree^2 Downing-Movshon says dots/degree^2/sec -- I don't get why sec is relevantspeed = 7;              % Dot-speed in deg/secloops = 3;              % A low-level drawing feature of DotsX codemotion_dur = 500;       % Motion stimulus duration in msec (fixed viewing time)% The black target imitates the annulus idea in the Kastner lab motion% localizer code, presumably to prevent tracking of individual dots% that move through the fixation point.blackTargetIdx = rAdd('dXtarget', 1, 'color', contrast_factor*[0 0 0],'penWidth',24,'diameter',black_annulus_diam,'visible',false);% add some dots and a targettargetIdx = rAdd('dXtarget', 1, 'color', contrast_factor*[255 255 255],'penWidth',24,'diameter',target_diam,'visible',false);dotsIdx = rAdd('dXdots', 1, 'color', contrast_factor*[255 255 255], 'direction',0,'coherence',coherence_array(1),...    'diameter',aperture_diam,'size',pixelsize,'loops',loops,'density',density,'speed',speed,'lifetimeMode','random', ...    'visible',false);% % %     rGraphicsDraw;% ROOT_STRUCT.dXtarget = draw(ROOT_STRUCT.dXtarget);% ROOT_STRUCT.dXdots = draw(ROOT_STRUCT.dXdots);% %     Screen('Flip', wdwPtr, [], 1)fontsize = 20;font_degrees = 0.7;str = sprintf ('Score: %d', score);%     textwidth = fontsize*length(str)/ppd_;textwidth = font_degrees*length(str);x_pos = -0.3*textwidth;textIdx_Score = rAdd('dXtext', 1, 'visible', false, ...    'x', x_pos, 'y', 0, ...    'size', floor(font_degrees*ppd_), ...    'font', 'Courier',  ...    'color', contrast_factor*[1 1 1]*255, ...    'string', str);RT = [];bl = 1;welcome5;% % Display score between blocks:% %         rSet('dXdots',dotsIdx,'speed',0);% rSet('dXtext',textIdx_Score,'string',sprintf('Score: %d', score),'visible',true);% rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);% % %         ROOT_STRUCT.dXdots = draw(ROOT_STRUCT.dXdots);% % ROOT_STRUCT.dXtarget = draw(ROOT_STRUCT.dXtarget);% % ROOT_STRUCT.dXtext = draw(ROOT_STRUCT.dXtext);% % Screen('Flip', wdwPtr, [], 1);% Using Rafal's names for trial-indexing of the returned data:% 'ib' refers to 'index beginning'% 'ie' refers to 'index end'% 'bl' is the block number% the main experimental loop% RT = [];money = 0;numblocks = length(RSI);for bl = 1 : numblocks% 	if bl ~= 1%         resting (numblocks - bl + 1 + 2, money );                resting_arrow(numblocks - bl + 1 + 2, money, cue_type(bl) );%     end        %     % Display score between blocks:%     %         rSet('dXdots',dotsIdx,'speed',0);%     rSet('dXtext',textIdx_Score,'string',sprintf('Score: %d', score),'visible',true);%     rSet('dXtarget',targetIdx,'color',contrast_factor*[255 255 255]);% %     %         ROOT_STRUCT.dXdots = draw(ROOT_STRUCT.dXdots);% %     ROOT_STRUCT.dXtarget = draw(ROOT_STRUCT.dXtarget);% %     ROOT_STRUCT.dXtext = draw(ROOT_STRUCT.dXtext);% %     Screen('Flip', wdwPtr, [], 1);            [STbl, irrelDirbl, ST_timebl, arrow_onsetbl, arrow_durbl, arrow_offsetbl, RTbl, ERbl, RDirbl, PiDirbl, score, premie_t,premie_d] = ...		block (RSI(bl), Shape(bl), coherence(bl), cue_type(bl), blockdur, ...        dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, ...		rkey, money, salary, ...        wdwPtr, pahandle_correct, pahandle_antic, daq);	ib = length(RT) + 1;					%index of the begining of inserted block	ie = length(RT) + length(RTbl);	%index of the end of inserted block	ST(ib:ie) = STbl;    irrelDir(ib:ie) = irrelDirbl;   % Direction of irrelevant motion on arrow trials (will equal ST on motion trials)	ST_time(ib:ie) = ST_timebl;    arrow_onset(ib:ie) = arrow_onsetbl;    arrow_dur(ib:ie) = arrow_durbl;    arrow_offset(ib:ie) = arrow_offsetbl;	RT(ib:ie) = RTbl;	ER(ib:ie) = ERbl;	RDir(ib:ie) = RDirbl;	blocknum(ib:ie) = bl;	trialnum(ib:ie) = 1:length(RTbl);% 	D(ib:ie) = Dbl(bl-1);% 	PI(ib:ie) = PIbl(bl-1);    D(ib:ie) = RSI(bl);    PI(ib:ie) = 0.5;	PiDir(ib:ie) = PiDirbl; % For 50:50 stimuli, this variable is meaningless	%    Dpen(ib:ie) = Dpenbl(bl);	% 9/19/05: Keeping track of premature responses with an array of cell arrays of time & direction vectors:	Premie_t(ib:ie) = premie_t;	Premie_d(ib:ie) = premie_d;		money = money + score * salary;        % While the following % 	save (filename);	end% resting2 (windowptr, 2, money, opponent_money );% resting (2, money);resting_arrow(numblocks - bl + 1 + 2, money, cue_type(bl) );% Now add in two blocks that test signal detection speed, each of 2.5 minutes% (leading to a total experiment time of 90 minutes):sig_det_instruction(salary);sig_det_resting( 2, money, 'Left' );% 10/27/08: Using the lowest coherence for the signal detection tasks. No% reason -- just have to pick one of the two currently being used.% 5/3/06: Adapting block.m for sig_det_block.m:% [Left_ST, Left_ST_time, Left_RT, Left_ER, score1, Left_premie_t, Left_premie_d] = ...% sig_det_block (coherence_array(1), blockdur/2, lkey, ...% rkey, 0.5, money, salary, 1, pahandle_correct, pahandle_antic,'Left',daq);% money = money + score1 * salary;[Left_ST, Left_ST_time, Left_RT, Left_ER, score1, Left_premie_t, Left_premie_d] = ...sig_det_block(RSI_poss(1), Shape_poss(1), coherence_array(1), blockdur, 'Left', ...    dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...    pahandle_correct, pahandle_antic, daq);% sig_det_resting(1,money,'Right', windowptr );sig_det_resting(1,money,'Right');% [Right_ST, Right_ST_time, Right_RT, Right_ER, score2, Right_premie_t, Right_premie_d] = ...% sig_det_block (coherence_array(1), blockdur/2, lkey, ...% rkey, 0.5, money, salary, 1, pahandle_correct, pahandle_antic, 'Right',daq );[Right_ST, Right_ST_time, Right_RT, Right_ER, score2, Right_premie_t, Right_premie_d] = ...sig_det_block(RSI_poss(1), Shape_poss(1), coherence_array(1), blockdur, 'Right', ...    dotsIdx, targetIdx, blackTargetIdx, textIdx_Score, ppd_, lkey, rkey, money, salary, ...    pahandle_correct, pahandle_antic, daq);money = money + score2 * salary;%Finishing the experimentsave (filename, 'ST', 'ST_time', 'arrow_onset', 'arrow_dur', 'arrow_offset', 'RT', 'ER', 'RDir', 'blocknum', 'trialnum', ...    'D', 'PI', 'PiDir', 'money', ...    'Left_ST', 'Left_ST_time', 'Left_RT', 'Left_ER', 'Left_premie_t', 'Left_premie_d', ...    'Right_ST', 'Right_ST_time', 'Right_RT', 'Right_ER', 'Right_premie_t', 'Right_premie_d', ...    'Premie_t', 'Premie_d', 'contrast_factor',...    'blank_time', 'pix_degree_size', 'aperture_diam','pixelsize', ...    'target_diam','black_annulus_diam','ppd_','density','speed','loops', ...    'waitdur','blockdur','numblocks');% thankyou (money)% opponent_money = thankyou (money, opponent_money, score1+score2, salary, windowptr);% money = 0; opponent_money = 0; salary = 0;rSet('dXdots',dotsIdx,'visible',false);rSet('dXtarget',targetIdx,'visible',false);rSet('dXtarget',blackTargetIdx,'visible',false);rGraphicsDraw;thankyou (money, score1+score2);% Now update the subject order file. By doing this at the end of the% experiment, interrupted sessions are totally ignored, both from the% perspective of the individual subject's order file and for the master% order file that enables counterbalancing of conditions across subjects% and sessions. This means that starting an interrupted session over% again will repeat the block ordering for the subject. Assuming that% interruptions typically happen early in the session because the% experimenter realized he/she made a mistake, this is not too problematic.% But if a power failure happens near the end of a session, they will get% exactly the same ordering the next time they do the session -- but in% that case, the subject will almost certainly want to come back on% another day and will hopefully forget the ordering, so this seems the% best solution for the problem of interruptions.SessionsCompleted = SessionsCompleted + 1;% save( subj_order_file, 'PI_vals', 'D_vals', 'SessionsCompleted' );% save( subj_order_file, 'PermutationList', 'SessionsCompleted' );save( subj_order_file, 'SessionsCompleted' );rDone;% Close the audio device:PsychPortAudio('Close', pahandle_correct);PsychPortAudio('Close', pahandle_antic);return% catch%     Screen('CloseAll');%     %     psychrethrow(psychlasterror);%     rethrow(lasterror);%     PsychPortAudio('Close', pahandle_correct);%     PsychPortAudio('Close', pahandle_antic);%     FlushEvents;% end